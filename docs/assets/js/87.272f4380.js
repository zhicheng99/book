(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{363:function(e,t,n){"use strict";n.r(t);var a=n(10),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"重学-js-为啥-await-不能用在-foreach-中详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重学-js-为啥-await-不能用在-foreach-中详解"}},[e._v("#")]),e._v(" 重学 JS：为啥 await 不能用在 forEach 中详解")]),e._v(" "),n("p",[e._v("这是重学 JS 系列的第三篇文章，写这个系列的初衷也是为了夯实自己的 JS 基础或者了解一些之前不知道的东西。既然是重学，肯定不会从零开始介绍一个知识点，如有遇到不会的内容请自行查找资料。")]),e._v(" "),n("p",[e._v("不知道你有没有写过类似的代码，反正以前我是写过")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function test() {\n let arr = [3, 2, 1]\n arr.forEach(async item => {\n  const res = await fetch(item)\n  console.log(res)\n })\n console.log('end')\n}\n\nfunction fetch(x) {\n return new Promise((resolve, reject) => {\n  setTimeout(() => {\n   resolve(x)\n  }, 500 * x)\n })\n}\n\ntest()\n\n\n")])])]),n("p",[e._v("我当时期望的打印顺序是")]),e._v(" "),n("blockquote",[n("p",[e._v("3")]),e._v(" "),n("p",[e._v("2")]),e._v(" "),n("p",[e._v("1")]),e._v(" "),n("p",[e._v("end")])]),e._v(" "),n("p",[e._v("结果现实与我开了个玩笑，打印顺序居然是")]),e._v(" "),n("blockquote",[n("p",[e._v("end")]),e._v(" "),n("p",[e._v("1")]),e._v(" "),n("p",[e._v("2")]),e._v(" "),n("p",[e._v("3")])]),e._v(" "),n("p",[n("strong",[e._v("为什么？")])]),e._v(" "),n("p",[e._v("其实原因很简单，那就是 forEach 只支持同步代码。")]),e._v(" "),n("p",[e._v("我们可以参考下 Polyfill 版本的 forEach，简化以后类似就是这样的伪代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("while (index < arr.length) {\n  // 也就是我们传入的回调函数\n  callback(item, index)\n}\n")])])]),n("p",[e._v("从上述代码中我们可以发现，forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。并且你在 callback 中即使使用 break 也并不能结束遍历。")]),e._v(" "),n("p",[n("strong",[e._v("怎么解决？")])]),e._v(" "),n("p",[e._v("一般来说解决的办法有两种。")]),e._v(" "),n("p",[e._v("第一种是使用 Promise.all 的方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("async function test() {\n let arr = [3, 2, 1]\n await Promise.all(\n  arr.map(async item => {\n   const res = await fetch(item)\n   console.log(res)\n  })\n )\n console.log('end')\n}\n\n\n")])])]),n("p",[e._v("这样可以生效的原因是 async 函数肯定会返回一个 Promise 对象，调用 map 以后返回值就是一个存放了 Promise 的数组了，这样我们把数组传入 Promise.all 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 fetch 是顺序完成的，可以选择第二种方式。")]),e._v(" "),n("p",[e._v("第一种方法是使用 for...of")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("async function test() {\n let arr = [3, 2, 1]\n for (const item of arr) {\n  const res = await fetch(item)\n  console.log(res)\n }\n console.log('end')\n}\n\n\n")])])]),n("p",[e._v("这种方式相比 Promise.all 要简洁的多，并且也可以实现开头我想要的输出顺序。")]),e._v(" "),n("p",[e._v("但是这时候你是否又多了一个疑问？为啥 for...of 内部就能让 await 生效呢。")]),e._v(" "),n("p",[e._v("因为 for...of 内部处理的机制和 forEach 不同，forEach 是直接调用回调函数，for...of 是通过迭代器的方式去遍历。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("async function test() {\n let arr = [3, 2, 1]\n const iterator = arr[Symbol.iterator]()\n let res = iterator.next()\n while (!res.done) {\n  const value = res.value\n  const res1 = await fetch(value)\n  console.log(res1)\n  res = iterator.next()\n }\n console.log('end')\n}\n\n")])])]),n("p",[e._v("最后")]),e._v(" "),n("p",[e._v("以上就是本篇文章的全部内容了，如果你还有什么疑问欢迎在评论区与我互动。")]),e._v(" "),n("p",[e._v("我所有的系列文章都会在我的 Github 中最先更新，有兴趣的可以关注下。今年主要会着重写以下三个专栏")]),e._v(" "),n("p",[e._v("重学 JS")]),e._v(" "),n("p",[e._v("React 进阶")]),e._v(" "),n("p",[e._v("重写组件")]),e._v(" "),n("p",[e._v("以上所述是小编给大家介绍的为啥await 不能用在 forEach 中详解整合，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！")]),e._v(" "),n("p",[e._v("文章来源：https://www.jb51.net/article/159768.htm")]),e._v(" "),n("backTop")],1)}),[],!1,null,null,null);t.default=s.exports}}]);