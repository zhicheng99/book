(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{429:function(a,t,e){"use strict";e.r(t);var r=e(10),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"wasm-在动画引擎中的设计优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wasm-在动画引擎中的设计优化"}},[a._v("#")]),a._v(" WASM 在动画引擎中的设计优化")]),a._v(" "),e("blockquote",[e("p",[a._v("‍♀️ 编者按：本文作者是蚂蚁集团前端工程师阿侎，探讨一个图形动画领域的性能优化：如何在 canvas/webgl 的动画引擎设计上，使用 WASM 来优化性能？")])]),a._v(" "),e("h1",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("p",[a._v("WebAssembly 技术日趋稳定和成熟，在许多场景下已经被运用，其重要特性之一的性能更是作为用来被解决问题的手段。")]),a._v(" "),e("p",[a._v("关于其基础原理、适应场景等本文不再赘述。动画引擎本身原理这里也作为基础跳过不说。")]),a._v(" "),e("p",[a._v("此篇主要探讨一个图形动画领域的性能优化：如何在 canvas/webgl 的动画引擎设计上，使用 WASM 来优化性能？")]),a._v(" "),e("p",[a._v("让我们首先规定下动画引擎：")]),a._v(" "),e("blockquote",[e("p",[a._v("具备类似 CSS Animation / Web Animation Api 的完备功能，而非简单的帧时间计数器。")])]),a._v(" "),e("ol",[e("li",[a._v("这需要有暂停、恢复、变速、跳转、反向、取消、完成、轮播等一系列控制能力；")]),a._v(" "),e("li",[a._v("更完整的是需要有简单 api，赋予一个类似 DOM 的对象任意动画功能的编程能力，可以入参；")]),a._v(" "),e("li",[a._v("如果可以，最好支持 CSS 的单位（rem、vw）、停留模式、事件。")])]),a._v(" "),e("p",[a._v("以上 3 点层级依次递增，根据完整度不同。")]),a._v(" "),e("p",[a._v("第 1 点是基础，第 2 点较普遍，第 3 点比较苛刻可以有选择实现（和渲染强关联）。")]),a._v(" "),e("h1",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),e("p",[a._v("很多分享中都能见到，WASM 适合密集计算型，能提升相对原本 js 的小几倍。这对于渲染或动画来说已经很难得了。")]),a._v(" "),e("p",[a._v("但是 WASM 需要规避频繁调用和数据交换，一帧一次渲染内 api 数据交互需要保证数量很少才行。这也和动画 api 的使用设计相关。如果没注意这个，可能最后性能的改进还不如数据交互消耗得多。")]),a._v(" "),e("p",[a._v("比如动画每帧内的计算都在 WASM 内部完成，一帧中选取适合的时机一次性吐出。而初始化动画等行为是少数性甚至一次性操作，这个特点可以忽视掉，不会有调用次数过多场景。")]),a._v(" "),e("p",[a._v("另：在实测中同时尝试了几种编程语言的 WASM 版本，最初很想用前端熟悉的 Assembly Script。但在性能测试中 AS 提升极为有限，甚至没啥区别。")]),a._v(" "),e("p",[a._v("最终采用了 Rust：https://github.com/karasjs/wasm")]),a._v(" "),e("h1",{attrs:{id:"限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[a._v("#")]),a._v(" 限制")]),a._v(" "),e("p",[a._v("先说说限制。")]),a._v(" "),e("p",[a._v("动画引擎和渲染引擎强关联，很多优化逻辑都要和渲染引擎绑定。")]),a._v(" "),e("p",[a._v("动画的种类也有很多种，最常见的是 transform 和 opacity，无论是写 CSS 还是播放一段 Lottie，设计师最常用基础手段便是这 2 个。")]),a._v(" "),e("p",[a._v("再比较常见一些的则是 visibility、color、border、z-index、font 等。")]),a._v(" "),e("p",[a._v("再往后不是那么频繁的则是width、margin、perspective、路径、矢量形状等。")]),a._v(" "),e("p",[a._v("这里不讨论高级或封装的如骨骼、粒子、shader 效果。")]),a._v(" "),e("p",[a._v("如果这些全部用 WASM 来写，势必会有成本问题：")]),a._v(" "),e("ol",[e("li",[a._v("无论 C++ 还是 Rust 还是其它，编写难度成本都不容忽视；")]),a._v(" "),e("li",[a._v("有些甚至是扩展成本，比如 font、width、路径、矢量动画，它和渲染引擎耦合极重，WASM 等于还要再实现一遍渲染逻辑；")]),a._v(" "),e("li",[a._v("调试维护也是一种成本。")])]),a._v(" "),e("p",[a._v("因此本文以最常见的 transform 和 opacity 为例（这 2 个可以说一模一样，和渲染逻辑解耦脱钩，下文举例统称为 transform），其它的如果想继续实现可以举一反三。")]),a._v(" "),e("h1",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),e("p",[a._v("只关注 transform 的话，那么所有渲染相关的数据存取都要关注分离。1 个 Node 节点（可以理解为一个舞台对象）本身是个 JS 对象，还会对应 1 个 WASM 的对象，我们称之为 WASM Node。那么这 2 个属性也自然跟随 WASM Node。")]),a._v(" "),e("p",[a._v("1 个 Node 会有任意个动画对象，和这2项相关的是纯 WASM Animation（红色）；不相关的是纯 JS Animation（蓝色）。也时常会出现一个动画中同时有 WASM 和 JS 的混合情况（绿色）。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/f6f1ffeac0fe4328b9e0b28307ce1c12~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=XLOBC8hZA5yq27clXsw4fgwvt%2Bk%3D",alt:""}})]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 纯JS动画，x可以理解为css的left\nnode.animate([\n  { x: 0 },\n  { x: 100 },\n], {\n  duration: 1000,\n});\n// 纯WASM动画，rotateZ即平面旋转\nnode.animate([\n  { rotateZ: 0 },\n  { rotateZ: 90 },\n], {\n  duration: 1000,\n});\n// 混合动画都有的情况\nnode.animate([\n  { x: 0, rotateZ: 0 },\n  { x: 100, rotateZ: 90 },\n], {\n  duration: 1000,\n});\n")])])]),e("p",[a._v("这在数据结构上对设计提出了挑战，已有的 JS 动画引擎部分最好修改少，且能适配 WASM 动画。")]),a._v(" "),e("p",[a._v("笔者采用了所有动画依旧是 JS 为入口，在初始化过后，如果有和 transform 相关的数据（指帧数据），这个 JS 动画对象会新建一个 WASM 动画对象并产生关联，将 transform 的数据传递给 WASM，JS 里删除。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/cac628c6099e4072a575587e3d8d1f50~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=iKQF7CvDf8%2FCrYL1%2BNlM957%2Ft2Y%3D",alt:""}})]),a._v(" "),e("p",[a._v("红色的 WASM 动画都被包含在蓝色的 JS 的动画中了，如果是个完全的 WASM 动画，那么 JS 很像个纯代理，可以设置个 ignore 标识。")]),a._v(" "),e("h1",{attrs:{id:"流程时钟"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流程时钟"}},[a._v("#")]),a._v(" 流程时钟")]),a._v(" "),e("p",[a._v("先说下 JS 动画引擎的一些流程，它以及它的前置条件或知识。")]),a._v(" "),e("p",[a._v("任意的数据更新，都应该是同步的，这点毋庸置疑。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 类CSS/WAA伪代码，节点向右平移100px距离\nnode.style.translateX = 100;\n\nconsole.log(node.style.translateX); // 输出100\n")])])]),e("p",[a._v("但渲染却未必是同步的，因为 1 次修改不可能立刻同步重绘，假如有 1000 个节点变化，立刻同步更新 1000 次，怎么优化也不可能达到流畅的效果。")]),a._v(" "),e("p",[a._v("所以渲染一定要设计成异步的，同步的代码执行更新后，下一帧再进行绘制。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 类CSS/WAA伪代码，很多节点同时更新\nfor(let i = 0; i < 1000; i++) {\n  nodes[i].style.translateX = 100;\n}\n\n// 渲染引擎在每个节点更新后会收到一条通知，下帧更新，无论多少节点都是同步通知，但下帧只重绘1次\nrequestAnimationFrame(() => {\n  draw(); // 只有1次渲染\n});\n")])])]),e("p",[a._v("动画引擎所引发的渲染更新也是如此，但有所不同的是，动画引擎有事件或回调。")]),a._v(" "),e("p",[a._v("事件或回调触发时，所有的动画引擎都应该在帧内完成数据更新，甚至是渲染更新好。事件或回调中甚至会触发控制其它动画或新的动画，所以这里的时钟顺序要想好。")]),a._v(" "),e("p",[a._v("例：2 个动画对象，这一帧，A 更改 translateX 为 10，B 更改 translateY 为 5。实际编码就是循环遍历已有的这 2 个动画对象，依次执行。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/ec50e6aef46845d581c641a9f427d547~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=ymmUPdRQbbhgJ1XAcBvxWopi%2FqY%3D",alt:""}})]),a._v(" "),e("p",[a._v("如果有 frame 事件，即动画每帧更新事件，那么不能在 A 更新结束后 B 还未更新就立刻触发，因为此时有歧义：translateY 应该是多少？是否应该是更新后的5？")]),a._v(" "),e("p",[a._v("frame 帧事件显然应该是所有数据更新后再触发的。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/8028271638f4495caf49a6d7969b0b4a~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=kyXZaP6E%2BEE89W34ibUdzGp9iIc%3D",alt:""}})]),a._v(" "),e("p",[a._v("将一帧内的动画分为 2 个前后时序，before 阶段执行所有的动画的数据更新，after 阶段执行所有的动画事件回调。时间复杂度从 O(n)变为O(2n)，可以接受。")]),a._v(" "),e("p",[a._v("在 after 阶段，其实很多逻辑都包含在内：判断是否结束、下一轮、结束停留状态等。")]),a._v(" "),e("p",[a._v("如果做得更好没有歧义，可以考虑将帧渲染环节放在 before 和 after 之间，这样事件触发时，画面甚至是与数据更新同步对应的。")]),a._v(" "),e("h1",{attrs:{id:"变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变化"}},[a._v("#")]),a._v(" 变化")]),a._v(" "),e("p",[a._v("现在 WASM 进场了。")]),a._v(" "),e("p",[a._v("前面说了，WASM 适合密集型计算，频繁通信会变得更慢。显然不能让蓝色 JS 动画执行时再去代理调用对应的红色 WASM 动画。假如动画有许多个，可能几十的数量就开始卡顿了。")]),a._v(" "),e("p",[a._v("因此，画布根节点 Root 对象必然持有所有 Node 节点的引用和动画对象的引用，且是排好序能高效访问的，无论在 JS 端还是 WASM 端都一样。")]),a._v(" "),e("p",[a._v("这样，在执行一帧更新时，before 阶段，Root 先通知 WASM Root 遍历所有的 WASM 动画，再遍历所有的 JS 动画对象（严格来说 WASM 和 JS 遍历前后顺序并不严格要求，甚至所有动画前后都顺序都不严格要求，只是实现可以按照顺序队列）。目前暂时只和 WASM 通信一次。")]),a._v(" "),e("p",[a._v("当 WASM 动画或 JS 动画真实产生更新时（有时动画两帧之间并无变化，可节省重绘成本），重绘。")]),a._v(" "),e("p",[a._v("再然后，after 阶段，Root 先通知 WASM Root 遍历所有的 WASM 动画，进行状态等数据检查，并保存到一块 SharedBuffer 上（有指针地址），再遍历所有的 JS 动画，将 SharedBuffer 的数据给到JS动画，执行 JS 动画的 after。目前再和 WASM 通信一次。")]),a._v(" "),e("p",[a._v("例：有如下 A、B、C、D 共 4 个动画，其中 C、D是 WASM 动画：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d66bafedc4584c77aee0e5e185ec3221~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=mS6JY8kGHMcmRjp9lGPQ1gKBoeY%3D",alt:""}})]),a._v(" "),e("p",[a._v("一帧内执行更新的时钟周期：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/fdb1e0c140a3459fa62e0dbd7d57327d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=hEYjZwTPCTNylt7XFtRXCAJ3uCc%3D",alt:""}})]),a._v(" "),e("p",[a._v("为什么 after 中要由红色 WASM 的 C 和 D 给到蓝色 JS 的 C 和 D 数据？因为此刻时间的计算都在 WASM 中。")]),a._v(" "),e("ul",[e("li",[a._v("当前时间应该是第几帧？")]),a._v(" "),e("li",[a._v("是这一帧的哪个位置（百分比）？")]),a._v(" "),e("li",[a._v("如果有缓动怎么计算（easing）？")]),a._v(" "),e("li",[a._v("播放到第几轮了？")]),a._v(" "),e("li",[a._v("是否是反向那一轮（CSS/WAA 的 direction 为 alternative）？")]),a._v(" "),e("li",[a._v("是否刚好到最后一帧结束停止了？")]),a._v(" "),e("li",[a._v("是还原还是停留（CSS/WAA 的 fill 为 forwards）？")])]),a._v(" "),e("p",[a._v("这些在 WASM 中计算会非常快，再加上帧数据计算本身。如果 JS 来算的话，一是会重复，二是本身性能优化的意义就失去了。")]),a._v(" "),e("p",[a._v("after 中蓝色的 C、D 通过 SharedBuffer 拿到数据后，就可以确定当前动画的一些状态数据，这是非常快的。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 伪代码，通过SharedBuffer地址拿WASM的数据\nlet n = wasmRoot.after(); // n返回有多少个wasm动画\nlet states = new Uint8Array(wasm.instance.memory.buffer, wasmRoot.states_ptr(), n);\n")])])]),e("h1",{attrs:{id:"复杂情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复杂情况"}},[a._v("#")]),a._v(" 复杂情况")]),a._v(" "),e("p",[a._v("上述情况还是太简单了，连混合绿色的动画都没有出现过。如果包含绿色混合动画，那么上面提到的那些在 WASM 和 JS 中是会重复计算的（但不包括帧数据计算本身）。这时候要考虑重复的这些性能损耗有多少，和 WASM 带来的提升相比如何。好在据经验来看，出现的频率以及损耗都较小，可以接受。")]),a._v(" "),e("p",[a._v("再看另外一个情况，如果 A、B、C、D 的顺序并不规整怎么办？")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/c177609d14d44527a06520338ee59f2b~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=nrlCCLXr6lPeYZ73MN089ru3e%2BM%3D",alt:""}})]),a._v(" "),e("p",[a._v("很容易出现这样的情况，JS 动画和 WASM 动画并不完整连续。")]),a._v(" "),e("p",[a._v("在 before 阶段，并没有什么影响，依旧是 WASM 独立执行遍历，然后 JS 再遍历。")]),a._v(" "),e("p",[a._v("在 after 阶段，有些不同。先是已知的 WASM，再是 JS，可 SharedBuffer 却要注意了。此刻 SharedBuffer 有 2 项数据，分别是 C 和 D 的。但 JS 拿到时并不知道是 A、B、C、D 哪 2 个的。前面简化例子中，我们假定了它是按顺序后出现的 C、D，这太过理想化。")]),a._v(" "),e("p",[a._v("这时候需要加个判断逻辑，先是 JS 代理的动画对象（有 WASM 动画引用）需要有个标识。然后 after 遍历 JS 动画对象时，没有代理的要忽略并计数，有代理的要根据索引 index 和当前计数形成偏移量 offset，来取 SharedBuffer。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 伪代码，通过SharedBuffer地址拿WASM的数据\nlet n = wasmRoot.after(); // n返回有多少个wasm动画\nlet states = new Uint8Array(wasm.instance.memory.buffer, wasmRoot.states_ptr(), n);\n// 偏移计数器\nlet offset = 0;\n// 循环JS动画\nfor(let i = 0; i < len; i++) {\n  let ja = jsAnimations[i];\n  // 有代理\n  if(ja.wasmAnimation) {\n    let state = states[i - offset];\n    // 处理传递数据\n  }\n  else {\n    offset++;\n  }\n  // 执行js的after\n  ja.after();\n}\n")])])]),e("h1",{attrs:{id:"刷新重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#刷新重绘"}},[a._v("#")]),a._v(" 刷新重绘")]),a._v(" "),e("p",[a._v("before 步骤执行完成后，after 之前是刷重绘。这里会出现第 3 次 WASM 交互，主要是 matrix 计算。")]),a._v(" "),e("p",[a._v("由于节点是个树形结构，有父子关系（兄弟关系对于 matrix 计算几乎无影响，除了 mask 节点这种相邻），对于 matrix 来说要算预乘。")]),a._v(" "),e("p",[a._v("较好的遍历方式是扁平化，将树形结构打平，形成 for 循环模式先序遍历，这点不在讨论范围内。")]),a._v(" "),e("p",[a._v("3 阶或 4 阶矩阵计算在 WASM 中也比 JS 快，不过性能的提升并没有动画引擎改写那么大。V8 等 JS 引擎对于这种简单热代码优化得要好些。")]),a._v(" "),e("p",[a._v("之后亦是通过 SharedBuffer 拿到一个 marix 队列，因为 matrix 是 16 长度的，所以长度注意 *16：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let matrix = new Float64Array(wasm.instance.memory.buffer, wasmRoot.matrix_ptr(), len * 16);\n")])])]),e("p",[a._v("查看 performance，也会发现占大头的还是动画中每个对象的执行：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e0f74492ebc34e3b92caaa093fa03654~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=Gd6CgJtpywIKtQm9%2BnYrx0CoH0k%3D",alt:""}})]),a._v(" "),e("p",[a._v("（红色动画引擎执行 before，蓝色重绘计算 matrix）")]),a._v(" "),e("p",[a._v("如果想进一步优化矩阵乘法，WASM 中可以使用 SIMD 指令，但只在较新浏览器中实现，比如 chrome91：https://chromestatus.com/feature/6533147810332672")]),a._v(" "),e("p",[a._v("另外像顶点计算等类似的东西，都可以放进 WASM 中，不仅性能更好，也没有垃圾回收的负担。这些优化初版暂时没有，后续考虑补上。")]),a._v(" "),e("h1",{attrs:{id:"精度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#精度"}},[a._v("#")]),a._v(" 精度")]),a._v(" "),e("p",[a._v("有个计算细节，在 WASM 中所有数字运算都应该先转为 f64 后再进行，因为 JS 中便是如此。如果使用 f32，那么便会出现精度不一致的现象。虽然表面上看起来肉眼无区别，但在一些细致化场景或者对精度要求高的情况，可能会出现意想不到的情况，且非常难以排查。")]),a._v(" "),e("p",[a._v("Rust 使用的 wasm-bindgen 在进行地址交换的时候，编译器有个对齐字节的操作。f64 和 f32 会使得对象的指针解引用时有所不同，f32 的 offset 是 4 个字节，f64 是 8 个字节，这种坑不注意也会困扰人许久。")]),a._v(" "),e("h1",{attrs:{id:"benchmark"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#benchmark"}},[a._v("#")]),a._v(" benchmark")]),a._v(" "),e("p",[a._v("继续使用之前的一万节点动画性能测试。要求：")]),a._v(" "),e("ol",[e("li",[a._v("使用 10000 个包含不同文字、背景色的节点，如果是 CANVAS 模式，降级到 5000 个；")]),a._v(" "),e("li",[a._v("所有节点同时进行不同的随机移动、旋转、缩放动画，无限往返；")]),a._v(" "),e("li",[a._v("统计 fps 对比，并附上测试 DEMO 源码。")])]),a._v(" "),e("p",[a._v("http://army8735.me/karasjs/karas/benchmark/karas-wasm-5k.htmlhttp://army8735.me/karasjs/karas/benchmark/karas-canvas-5k.htmlhttp://army8735.me/karasjs/karas/benchmark/pixi-canvas-5k.html")]),a._v(" "),e("p",[a._v("http://army8735.me/karasjs/karas/benchmark/karas-webgl-1w.htmlhttp://army8735.me/karasjs/karas/benchmark/karas-wasm-1w.htmlhttp://army8735.me/karasjs/karas/benchmark/pixi-webgl-1w.html")]),a._v(" "),e("p",[a._v("https://skottie.skia.org/662e5267a8b58896c5812c24ed61ef90?h=800&w=800")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d8e079229a6a4f4e9cabf987d183d56f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=fhTlmbnQvniz8YJA8CofYyR2VL8%3D",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/2469261a86004be5b601083d6047c5eb~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687574112&x-signature=VEESWb5T8WZeM8M5l3f8f3vRHLU%3D",alt:""}})]),a._v(" "),e("p",[a._v("神奇的是，pixi 在 pc 和 mobile 上表现差距极大，可能移动端有什么特殊优化。")]),a._v(" "),e("p",[a._v("实际上 pixi 的 DEMO 并不是完整的动画引擎，只是个计时器 tick，连层级 1 都不到，完整实现的话性能会大打折扣。")]),a._v(" "),e("p",[a._v("skottie 只有 webgl+wasm 模式，且功能受限（只有层级 1）不好比较，约等于 pixi。")]),a._v(" "),e("h1",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),e("p",[a._v("目前初级版本还有一些细节可以优化，甚至还有新的想法可以尝试。")]),a._v(" "),e("p",[a._v("比如大头占比的动画执行，是否也可以考虑使用 SIMD？数量众多的动画对象，亦有些并发的味道，是否可以将那些帧数据中的样式数据（即 transform/matrix/opacity 某个变化）平铺到一些矩阵当中，直接用并行矩阵计算来加速？")]),a._v(" "),e("p",[a._v("期待 WASM 的更好的发展。")]),a._v(" "),e("p",[a._v("作者:阿侎")]),a._v(" "),e("p",[a._v("来源:微信公众号:支付宝体验科技")]),a._v(" "),e("p",[a._v("出处\n:https://mp.weixin.qq.com/s/pmH559vnTpQ7HLOssyKqiA")]),a._v(" "),e("p",[a._v("文章来源：https://www.toutiao.com/article/7203529991232078393/?log_from=d239ee32ad891_1686969311972")]),a._v(" "),e("backTop")],1)}),[],!1,null,null,null);t.default=s.exports}}]);