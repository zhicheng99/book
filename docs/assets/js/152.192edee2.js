(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{384:function(t,n,e){"use strict";e.r(n);var a=e(10),r=Object(a.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h1",{attrs:{id:"实现一个多重继承类的核心方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现一个多重继承类的核心方法"}},[this._v("#")]),this._v(" 实现一个多重继承类的核心方法")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("/*\n* @Author: zhicheng\n* @Date:   2023-11-06 15:02:55\n* @Last Modified by:   zhicheng\n* @Last Modified time: 2023-11-21 16:28:20\n*/\n// 实现继承基类\nlet Class = {\n    extend:function({initialize=_=>{},members={},protos={}}){ \n       \n            var _this = this;\n            var newClass = function(options){\n\n                //静态成员\n                for(var i in members){\n                    this[i] = members[i];\n                }\n                //实例化时的参数也并到实例成员中\n                var options = options||{}\n                for(var i in options){\n\n                \t//成员是对象 进行扩展覆盖\n                    if(this[i] && Object.prototype.toString.call(this[i]) === '[object Object]'){\n                        this[i] = {\n                            ...this[i],\n                            ...options[i]\n                        }\n                    }else{\n\t                     this[i] = options[i];   \n                    }\n                \n                }\n\n                //执行初始化方法\n                initialize && initialize.call(this);\n\n\n                // this.extend = _this.extend;\n            };\n\n            newClass.extend = _this.extend; \n\n            //原型继承\n            newClass.prototype = {\n                ..._this.prototype,\n                ...protos\n            };\n            return newClass; \n    },\n    prototype:{\n    \tisObj:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object Object]';\n\t\t},\n\t\tisFun:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object Function]';\n\t\t},\n\t\tisArr:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object Array]';\n\t\t},\n\t\tisNum:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object Number]';\n\t\t},\n\t\tisBool:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object Boolean]';\n\t\t},\n\t\tisStr:function(o) {\n\t\t    return Object.prototype.toString.call(o) === '[object String]';\n\t\t},\n    \tqueue:function(arr) {\n\t\t    // 串行执行promise 构建队列 \n\t\t                var res=[];\n\t\t                var sequence = Promise.resolve();\n\t\t                arr.forEach(function (item) {\n\t\t                    sequence = sequence.then(item).then(data=>{\n\t\t                            res.push(data);\n\t\t                            return res\n\t\t                   }).catch(data=>{\n\t\t                       //有reject也返回\n\t\t                       res.push(data);\n\t\t                       return res;\n\t\t                   })\n\t\t                })\n\n\t\t                return sequence \n\t\t},\n        addEvent:function(target, eventType, handle) {\n\t\t     if (target.addEventListener) { \n\t\t          target.addEventListener(eventType, handle, false); \n\t\t      } else { \n\t\t          target.attachEvent(\"on\" + eventType, function () {\n\t\t            handle.call(target, arguments);\n\t\t          }); \n\t\t      }\n\t\t},\n\t\tremoveEvent:function(target, eventType, handle) {\n\t\t    if (target.removeEventListener) {                   // // 所有浏览器，除了 IE 8 及更早IE版本\n\t\t        target.removeEventListener(eventType, handle,false);\n\t\t    } else if (target.detachEvent) {                   // IE 8 及更早IE版本\n\t\t        target.detachEvent(\"on\"+eventType, handle);\n\t\t    }\n\t\t},\n\t\tremoveChildById: function(id) {\n\t\t   var item = document.getElementById(id);\n\t\t    if(item){ \n\t\t        document.getElementById('body').removeChild(item);\n\n\t\t        // document.body.removeChild(item);\n\t\t    }\n\t\t},\n\t\t/**\n\t\t * 取面对象 中心点\n\t\t * @Author   lizhicheng\n\t\t * @DateTime 2023-06-05T10:32:07+0800\n\t\t * @param    {[type]}                 lnglatarr [{poslon:11212,poslat:11},{poslon:11212,poslat:11}...]\n\t\t * @return   {[type]}                           [description]\n\t\t */\n\t\tcalculateCenter: function (lnglatarr) {\n\t\t     var total = lnglatarr.length;\n\t\t     var X = 0, Y = 0, Z = 0;\n\t\t     lnglatarr.forEach(function (lnglat) {\n\t\t         var lng = lnglat.poslon * Math.PI / 180;\n\t\t         var lat = lnglat.poslat * Math.PI / 180;\n\t\t         var x, y, z;\n\t\t         x = Math.cos(lat) * Math.cos(lng);\n\t\t         y = Math.cos(lat) * Math.sin(lng);\n\t\t         z = Math.sin(lat);\n\t\t         X += x;\n\t\t         Y += y;\n\t\t         Z += z;\n\t\t     });\n\t\t     X = X / total;\n\t\t     Y = Y / total;\n\t\t     Z = Z / total;\n\n\t\t     var Lng = Math.atan2(Y, X);\n\t\t     var Hyp = Math.sqrt(X * X + Y * Y);\n\t\t     var Lat = Math.atan2(Z, Hyp);\n\t\t     // console.log(Lng, Lat, Hyp);\n\t\t     return { lng: Lng * 180 / Math.PI, lat: Lat * 180 / Math.PI };\n\t\t },\n\t\t isExsitDom:function(id,parentDom=null){\n\t\t\tvar t = false;\n\n\t\t\tif(parentDom === null){\n\t\t\t\t\tthis.mapInstance.el.parentNode.childNodes.forEach(item=>{\n\t\t\t\t\t\tif(item.id === id){\n\t\t\t\t\t\t\tt = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}) \n\t\t\t}\n\t\n\n\t\t\treturn t;\n\t\t},\n\t\tfindDomById:function(id){\n\n\t\t\tvar tmp =[]\n\t\t\tvar innerF = parentNode=>{\n\t\t\t\tparentNode.childNodes.forEach(item=>{\n\t\t\t\t\tif(item.nodeType == 1){\n\t\t\t\t\t\ttmp.push(item);\n\t\t\t\t\t\titem.hasChildNodes() && innerF(item);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t//从地图容器下搜索所有节点\n\t\t\tthis.mapInstance.el.parentNode.hasChildNodes && innerF(this.mapInstance.el.parentNode);\n\n\t\t\tvar doms = tmp.filter(item=>item.id == id);\n\n\t\t\tif(doms.length>0){\n\t\t\t\treturn doms[0]\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t}, \n\t\t/**\n\t\t * 根据屏幕位置\n\t\t * @param  {[type]} paramObj [description]\n\t\t * @return {[type]}          [description]\n\t\t */\n\t\tgetScreenDistance:function(paramObj){\n\n\t\t},\n\t\tgetMapDistanceValue:function(paramObj){\n\t\t\tvar lng1 = paramObj.lng1\n\t\t\tvar lat1 = paramObj.lat1\n\n\t\t\tvar lng2 = paramObj.lng2\n\t\t\tvar lat2 = paramObj.lat2\n\t\n\t\t\tvar radLat1 = lat1*Math.PI / 180.0;\n\t\t\tvar radLat2 = lat2*Math.PI / 180.0;\n\t\t\tvar a = radLat1 - radLat2;\n\t\t\tvar  b = lng1*Math.PI / 180.0 - lng2*Math.PI / 180.0;\n\t\t\tvar s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a/2),2) +\n\t\t\tMath.cos(radLat1)*Math.cos(radLat2)*Math.pow(Math.sin(b/2),2)));\n\t\t\ts = s *6378.137 ;// EARTH_RADIUS;\n\t\t\ts = Math.round(s * 10000) / 10000;\n\t\n\t\t\treturn s * 1000\n\t\t},\n\t\t/**\n\t\t * 通过经纬度获取两点实际距离 {lat1,  lng1,  lat2,  lng2}\n\t\t * @param  {[type]} paramObj [description]\n\t\t * @return {[type]}          [description]\n\t\t */\n\t\tgetMapDistance: (paramObj)=> {\n\t\t    // console.log(paramObj)\n\t\t    let s = this.getMapDistanceValue(paramObj);\n\t\t  \n\t\t    if (isNaN(s)) {  \n\t\t        return 0+'m';  \n\t\t    }  \n\t\t  \n\t\t    if (s > 1000) {\n\t\t        //    大于1000米时\n\t\t        s = Math.floor(s/1000 * 100) / 100;\n\t\t        s = s + 'km'\n\t\t    } else {\n\t\t        //    小于1000米直接返回\n\t\t        s = s + 'm'\n\t\t    }\n\t\t  \n\t\t    return s;\n\t\t}\n    }\n}\n\nexport default Class;\n")])])]),n("backTop")],1)}),[],!1,null,null,null);n.default=r.exports}}]);