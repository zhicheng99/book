(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{307:function(t,n,e){"use strict";e.r(n);var a=e(10),i=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"canvas图片、文字在移动端显示模糊问题-解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#canvas图片、文字在移动端显示模糊问题-解决方案"}},[t._v("#")]),t._v(" canvas图片、文字在移动端显示模糊问题 解决方案")]),t._v(" "),e("p",[t._v("项目需要画一个饼图，个插件没找到符合要求的，于是自己手动画了一个。可是到移动端的时候，或出现模糊不清的情况，研究了一下是高清屏的问题。")]),t._v(" "),e("p",[t._v("因为 canvas 不是矢量图，而是像图片一样是位图模式的。高 dpi 显示设备意味着每平方英寸有更多的像素。也就是说二倍屏，浏览器就会以2个像素点的宽度来渲染一个像素，该 canvas 在 Retina 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊。")]),t._v(" "),e("p",[t._v("因此，要做 Retina 屏适配，关键是知道当前屏幕的设备像素比，然后将 canvas 放大到该设备像素比来绘制，然后将 canvas 压缩到一倍来展示。")]),t._v(" "),e("p",[t._v("所以只要加上以下代码即可：")]),t._v(" "),e("p",[t._v("**")]),t._v(" "),e("div",{staticClass:"language-e-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("        // *****************解决移动端糊的问题\n        let dpr = window.devicePixelRatio; // 假设dpr为2\n        // 获取css的宽高\n        let { width: cssWidth, height: cssHeight } = canvas.getBoundingClientRect();\n        // 根据dpr，扩大canvas画布的像素，使1个canvas像素和1个物理像素相等\n        canvas.style.width = canvas.width + 'px';\n        canvas.style.height = canvas.height + 'px';\n   \n        canvas.width = dpr * cssWidth;\n        canvas.height = dpr * cssHeight;\n        // 由于画布扩大，canvas的坐标系也跟着扩大，如果按照原先的坐标系绘图内容会缩小\n        // 所以需要将绘制比例放大\n        ctx.scale(dpr,dpr);\n        // **************************\n")])])]),e("p",[t._v("下面开始进行画图，填充文字就可以了，出来的效果就非常清晰了。")]),t._v(" "),e("p",[t._v("解决前：")]),t._v(" "),e("p",[e("img",{attrs:{src:"//upload-images.jianshu.io/upload_images/18030682-7a0e7551f48f27cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/318/format/webp",alt:""}})]),t._v(" "),e("p",[t._v("image.png")]),t._v(" "),e("p",[t._v("解决后：")]),t._v(" "),e("p",[e("img",{attrs:{src:"//upload-images.jianshu.io/upload_images/18030682-9b7b1ebbdc930c3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/316/format/webp",alt:""}})]),t._v(" "),e("p",[t._v("image.png")]),t._v(" "),e("p",[t._v("下面贴出来我的完整代码：")]),t._v(" "),e("p",[t._v("**")]),t._v(" "),e("div",{staticClass:"language-e-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<canvas id=\"canvas\" width={200} height={200} />\n\n let canvas = document.getElementById('canvas');\n      if(canvas.getContext) {\n        let ctx = canvas.getContext('2d');\n        // *****************解决移动端糊的问题\n        let dpr = window.devicePixelRatio; // 假设dpr为2\n        // 获取css的宽高\n        let { width: cssWidth, height: cssHeight } = canvas.getBoundingClientRect();\n        // 根据dpr，扩大canvas画布的像素，使1个canvas像素和1个物理像素相等\n        canvas.style.width = canvas.width + 'px';\n        canvas.style.height = canvas.height + 'px';\n   \n        canvas.width = dpr * cssWidth;\n        canvas.height = dpr * cssHeight;\n        // 由于画布扩大，canvas的坐标系也跟着扩大，如果按照原先的坐标系绘图内容会缩小\n        // 所以需要将绘制比例放大\n        ctx.scale(dpr,dpr);\n        // **************************\n\n        for(let i = 0; i < listSubPercent.length; i++) {\n          ctx.beginPath();\n          let startAngle = listSubPercent[i] * Math.PI / 180;\n          let endAngle = listSubPercent[i + 1] * Math.PI / 180;\n          ctx.arc(pointX, pointY, sectorR, startAngle, endAngle, false);\n          ctx.lineTo(pointX, pointY); //转折点\n          ctx.fillStyle = colorList[i];\n          ctx.fill(); //扇形填充\n        }\n        //绘制圆形\n        ctx.beginPath();\n        ctx.moveTo(pointX, pointY); //起始点中心坐标点\n        let startAngle = 0; // 开始点\n        let endAngle = 2 * Math.PI;\n        ctx.arc(pointX, pointY, circleR, startAngle, endAngle, true);\n  \n        ctx.fillStyle = fillColor; //作对比  暂用此颜色  需要改为黑色才能和三角拼接  rgba(255,165,0,1)类也可以\n        ctx.fill(); //圆形填充\n\n        //中间位置的度数\n        let middleDegree = (listSubPercent[num + 1] - listSubPercent[num]) / 2 + listSubPercent[num];\n        middleDegree = 90 - middleDegree;\n        //三角形底边的另一个点的位置\n        let X1 = Math.sin((middleDegree + 90) * Math.PI / 180) * 30 + pointX;\n        let Y1 = Math.cos((middleDegree + 90) * Math.PI / 180) * 30 + pointY;\n        //三角形底边的一个点的位置\n        let X = Math.sin((middleDegree + 270) * Math.PI / 180) * 30 + pointX;\n        let Y = Math.cos((middleDegree + 270) * Math.PI / 180) * 30 + pointY;\n        //三角形顶点的位置\n        let RX = Math.sin(middleDegree * Math.PI / 180) * 60 + pointX;\n        let RY = Math.cos(middleDegree * Math.PI / 180) * 60 + pointY;\n        ctx.beginPath();\n        ctx.moveTo(X1, Y1); //起始点\n        ctx.lineTo(X, Y); //转折点\n        ctx.lineTo(RX, RY); //结束点\n        ctx.fillStyle = fillColor;\n        ctx.fill(); //三角形填充\n\n        // 绘制文字\n        ctx.font = \"16px sans-serif\";\n        ctx.fillStyle = textColor;\n        ctx.fillText(data[0].ratingagency, 70, 95);\n        ctx.font = \"14px sans-serif\";\n        ctx.fillStyle = textColor;\n        ctx.fillText(`${data[0].percentage}%`, 80, 115);\n      }\n")])])]),e("p",[t._v("文章来源：https://www.jianshu.com/p/aaa9a187b301")]),t._v(" "),e("backTop")],1)}),[],!1,null,null,null);n.default=i.exports}}]);