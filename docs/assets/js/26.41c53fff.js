(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{304:function(n,t,e){"use strict";e.r(t);var r=e(10),a=Object(r.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"根据关系线生成布局-计算行-列-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据关系线生成布局-计算行-列-算法"}},[this._v("#")]),this._v(" 根据关系线生成布局（计算行 列）算法")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('var lineData = [\n{"soruce":"1" ,"taget":"2","attr":"接口调用",status:"0"},\n{"soruce":"1" ,"taget":"3","attr":"接口调用",status:"0"},\n{"soruce":"2" ,"taget":"4","attr":"接口调用",status:"0"},\n{"soruce":"2" ,"taget":"5","attr":"接口调用",status:"0"},\n{"soruce":"3" ,"taget":"6","attr":"流程数据",status:"0"},\n{"soruce":"3" ,"taget":"7","attr":"流程数数据",status:"0"},\n{"soruce":"7" ,"taget":"8","attr":"流程数数据",status:"0"},\n{"soruce":"9" ,"taget":"10","attr":"流程数数据",status:"0"}\n\n\n]\n\n/*\n\n解析该示例结构（每一个结点看作是一个分组）\n      1\n    /  \\\n   2    3\n  / \\   /\\\n 4   5  6 7\n           \\\n            8 \n      9\n      |\n      10\n  \n\n*/\n\nfunction filterTargetId(targetArr,firstId,lineData){\n    //只保留可能从首节点一级一级都可以找到的节点 （断掉的/没有联系的丢掉）\n    console.log(\'需要查找到目标id\');\n    console.log(targetArr);\n    console.log(\'首节点：\'+firstId);\n\n   \n  \n    var isFindNode =function(lineData,firstNode,lastNode){ \n\n            //从最后的元素往上走 需要多少步找到第一个元素 那么结构就是多少层\n            var finded = false\n            var inner = function(){\n                for(var i = 0; i<lineData.length; i++){\n                    if(lastNode == lineData[i].taget){\n                        if(lineData[i].soruce == firstNode){\n                            console.log(\'找到了\');\n                            finded = true;\n                        \n                        }else{\n                            // console.log(\'没找到\');\n                            lastNode = lineData[i].soruce;\n                            inner();\n\n                        }\n                        break;\n                    }\n                }\n            }\n\n\n            inner(); \n            return finded;\n        }\n\n        var idsObj = [];\n        targetArr.forEach(function(item){\n            idsObj.push({\n                id:item,\n                finded:isFindNode(lineData,firstId,item)\n            })\n        })\n \n\n    var tmp = [];\n    idsObj.forEach(function(item){\n        if(item.finded){\n            tmp.push(item.id);\n        }\n    })\n   return tmp;\n}\n\nfunction findLastNodeId(lineData,firstId){\n     //找到初始的节点id  \n    // var sourceArr = lineData.map(function(item){\n    //     return item.soruce\n    // }) \n    var sourceArr = [firstId];\n\n    var targetArr = lineData.map(function(item){\n        return item.taget;\n    }) \n\n    //过滤掉没有关联关系的\n    targetArr = filterTargetId(targetArr,firstId,lineData);\n    console.log(\'过滤完后的节点：\')\n    console.log(targetArr);\n   \n\n    var targetNum = {};\n    for(var j = 0; j<targetArr.length;j++){\n        targetNum[targetArr[j]] = 0;\n    }\n\n     for(var i = 0; i<sourceArr.length; i++){\n        for(var j = 0; j<targetArr.length;j++){ \n            if(sourceArr[i] == targetArr[j]){ \n                targetNum[targetArr[j]] +=1;\n            }\n        }\n    } \n\n\n    // console.log(targetNum);\n    var tmp = \'\';\n    for(var i in targetNum){\n        if(targetNum[i] == 0){\n            tmp = (i);\n        }\n    } \n\n    return {\n        id:tmp\n    }\n  \n}\n\nfunction findFristNodeId(lineData){\n\n    //找到初始的节点id  \n    var sourceArr = lineData.map(function(item){\n        return item.soruce;\n    }) \n    var targetArr = lineData.map(function(item){\n        return item.taget;\n    }) \n \n\n    //目标里target没有的source的id 即是初始节点\n    var sourceNum = {};\n    for(var j = 0; j<sourceArr.length;j++){\n        sourceNum[sourceArr[j]] = 0;\n    }\n\n    for(var i = 0; i<targetArr.length; i++){\n        for(var j = 0; j<sourceArr.length;j++){ \n            if(targetArr[i] == sourceArr[j]){ \n                sourceNum[sourceArr[j]] +=1;\n            }\n        }\n    }  \n    var tmp = [];\n    for(var i in sourceNum){\n        if(sourceNum[i] == 0){\n            tmp.push(i);\n        }\n    } \n \n    return {\n        id:tmp\n    }\n}\n\nfunction getLevNum(lineData,firstNode,lastNode){\n \n\n    var firstNode = firstNode.id;\n    var lastNode = lastNode.id;\n\n    //从最后的元素往上走 需要多少步找到第一个元素 那么结构就是多少层\n    var num = 1; \n    var inner = function(){\n        for(var i = 0; i<lineData.length; i++){\n            if(lastNode == lineData[i].taget){\n                if(lineData[i].soruce == firstNode){\n                    // console.log(\'找到了\');\n                }else{\n                    // console.log(\'没找到\');\n                    lastNode = lineData[i].soruce;\n                    inner();\n                    num++;\n\n                }\n                break;\n            }\n        }\n    }\n\n\n    inner(); \n\n    return num+1\n}\n\n\n//计算最能排多少列\nfunction getMaxColumn(lineData,levNum){\n    //按每层排一个 看最后一层剩多少元素 就是最多排多少列\n    //计算分组的结点数量\b\n    var sourceArr = lineData.map(function(item){\n        return item.soruce;\n    })\n    var targetArr = lineData.map(function(item){\n        return item.taget;\n    })\n    var tmp  = sourceArr.concat(targetArr);\n\n    //去重\n    function unique1(arr){\n        var hash=[];\n        for (var i = 0; i < arr.length; i++) {\n            if(hash.indexOf(arr[i])==-1){\n            hash.push(arr[i]);\n            }\n        }\n        return hash;\n    }\n\n    tmp = unique1(tmp); \n\n    return tmp.length-(levNum-1);\n}\n\n//每一层各有哪些node 记录id\nfunction perLevContainerNode(lineData){\n\n\n    var findTarget = function(sourceIdArr){ \n\n        var tmp = [];\n        for(var i = 0; i<sourceIdArr.length; i++){\n            for(var j=0; j<lineData.length; j++){\n                if(sourceIdArr[i] == lineData[j].soruce){ \n                    tmp.push(lineData[j].taget);\n                }\n            }\n        } \n\n        return tmp;\n    }\n\n    var firstNodeIds = findFristNodeId(lineData);\n    console.log(\'首节点：\');\n    console.log(firstNodeIds.id);\n    var allLev = [];\n    for(var j =0; j<firstNodeIds.id.length; j++){\n        var perLastId = findLastNodeId(lineData,firstNodeIds.id[j]);\n        console.log(\'perLastId:\');\n        console.log(perLastId.id);\n\n        var levNum = getLevNum(lineData,{id:firstNodeIds.id[j]},perLastId); \n        console.log(levNum);\n        var lev = [];\n        for(var i = 0; i<levNum; i++){\n            if(i ==0){  //第一层\n                // var firstNode = findFristNodeId(lineData);\n                var firstNode ={id:firstNodeIds.id[j]}\n                lev = [[firstNode.id]];\n  \n            }else{\n                var sourceIdArr = lev[i-1]; //开始点\n            \n                lev[i] = findTarget(sourceIdArr);  //要据开始点找出它指向所有子节点\n            }\n        } \n        console.log(\'分组关系\'+j)\n        console.log(lev);\n        allLev.push(lev);\n        // return lev; \n\n    } \n\n    console.log(allLev);\n\n    //分层再并起来\n    var tmp = [];\n    allLev.forEach(function(item){\n        tmp = tmp.concat(item);\n    })\n\n    return tmp;\n  \n\n    // console.log(findFristNodeId(lineData));\n    // console.log(findLastNodeId(lineData));\n    return false;\n\n    var levNum = getLevNum(lineData,findFristNodeId(lineData),findLastNodeId(lineData));\n    var index = 0;\n    var lev = [];\n    for(var i = 0; i<levNum; i++){\n        if(i ==0){  //第一层\n            var firstNode = findFristNodeId(lineData);\n            lev = [[firstNode.id]];\n \n        }else{\n            var sourceIdArr = lev[i-1]; //开始点\n        \n            lev[i] = findTarget(sourceIdArr);  //要据开始点找出它指向所有子节点\n        }\n    } \n\n\n    return lev;\n}\n\n\n// var num  = getLevNum(lineData,findFristNodeId(lineData),findLastNodeId(lineData));\n// console.log(\'一共有\'+num+\'层\');\n// var column = getMaxColumn(lineData,num);\n// console.log(\'最多可以排\'+column+\'列\')\n\n//要据连线情况 计算出每一层的对象布局情况\nvar levObj = perLevContainerNode(lineData); \nconsole.log(\'最后的分层结果\');\nconsole.log(levObj);\n\n')])])]),t("backTop")],1)}),[],!1,null,null,null);t.default=a.exports}}]);