(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{403:function(e,t,r){"use strict";r.r(t);var n=r(10),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"object-defineproperty和object-defineproperties"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty和object-defineproperties"}},[e._v("#")]),e._v(" Object.defineProperty和Object.defineProperties()")]),e._v(" "),r("p",[e._v("JavaScript提供了一个内部数据结构，用来描述一个对象的属性的"),r("em",[r("strong",[e._v("行为***，控制它的行为。这被称为")]),e._v("“属性描述对象”")]),e._v("*（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。")]),e._v(" "),r("p",[r("strong",[e._v("下面是属性描述对象的一个实例。")])]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-tsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("{\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false,\n  get: undefined,\n  set: undefined\n}\n")])])]),r("p",[r("strong",[e._v("属性描述对象提供6个元属性。")])]),e._v(" "),r("ul",[r("li",[e._v("（1）value")])]),e._v(" "),r("p",[e._v("value存放该属性的属性值，默认为undefined。")]),e._v(" "),r("ul",[r("li",[e._v("（2）writable")])]),e._v(" "),r("p",[e._v("writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。")]),e._v(" "),r("ul",[r("li",[e._v("（3）enumerable")])]),e._v(" "),r("p",[e._v("enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。")]),e._v(" "),r("ul",[r("li",[e._v("（4）configurable")])]),e._v(" "),r("p",[e._v("configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。")]),e._v(" "),r("ul",[r("li",[e._v("（5）get")])]),e._v(" "),r("p",[e._v("get存放一个函数，表示该属性的取值函数（getter），默认为undefined。")]),e._v(" "),r("ul",[r("li",[e._v("（6）set")])]),e._v(" "),r("p",[e._v("set存放一个函数，表示该属性的存值函数（setter），默认为undefined。")]),e._v(" "),r("hr"),e._v(" "),r("h3",{attrs:{id:"object-getownpropertydescriptor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-getownpropertydescriptor"}},[e._v("#")]),e._v(" Object.getOwnPropertyDescriptor()")]),e._v(" "),r("p",[r("code",[e._v("Object.getOwnPropertyDescriptor()")]),e._v("方法可以读出对象自身属性的属性描述对象。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-dart extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = { p: 'a' };\n\nObject.getOwnPropertyDescriptor(o, 'p')\n// Object { value: \"a\",\n//   writable: true,            默认都是true\n//   enumerable: true,\n//   configurable: true\n// }\n")])])]),r("p",[e._v("上面代码表示，使用 "),r("code",[e._v("Object.getOwnPropertyDescriptor()")]),e._v("方法，读取o对象的p属性的属性描述对象。")]),e._v(" "),r("hr"),e._v(" "),r("h3",{attrs:{id:"object-defineproperty-object-defineproperties"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-object-defineproperties"}},[e._v("#")]),e._v(" Object.defineProperty()，Object.defineProperties()")]),e._v(" "),r("p",[r("code",[e._v("Object.defineProperty()")]),e._v("方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-csharp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Object.defineProperty(object, propertyName, attributesObject)\n")])])]),r("p",[e._v("上面代码中，"),r("code",[e._v("Object.defineProperty()")]),e._v("方法接受三个参数:")]),e._v(" "),r("blockquote",[r("ul",[r("li",[e._v("第一个是属性所在的对象，")]),e._v(" "),r("li",[e._v("第二个是属性名（它应该是一个字符串），")]),e._v(" "),r("li",[e._v("第三个是属性的描述对象。比如，新建一个o对象，并定义它的p属性，写法如下。")])])]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-csharp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = Object.defineProperty({}, 'p', {\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\n\no.p\n// 123\n\no.p = 246;\no.p\n// 123\n// 因为writable为false，所以无法改变该属性的值\n")])])]),r("p",[e._v("如果属性已经存在，"),r("code",[e._v("Object.defineProperty()")]),e._v("方法相当于更新该属性的属性描述对象。")]),e._v(" "),r("p",[r("em",[r("strong",[e._v("需要注意的是，"),r("code",[e._v("Object.defineProperty")]),e._v("方法和后面的 "),r("code",[e._v("Object.defineProperties")]),e._v("方法，都有性能损耗，会拖慢执行速度，不宜大量使用。")])])]),e._v(" "),r("p",[e._v("如果一次性定义或修改多个属性，可以使用 "),r("code",[e._v("Object.defineProperties()")]),e._v("方法。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('var o = Object.defineProperties({}, {\n  p1: { value: 123, enumerable: true },\n  p2: { value: \'abc\', enumerable: true },\n  p3: { get: function () { return this.p1 + this.p2 },\n    enumerable:true,\n    configurable:true\n  }\n});\n\no.p1 // 123\no.p2 // "abc"\no.p3 // "123abc"\n')])])]),r("p",[e._v("上面代码中的p3属性，定义了取值函数get。这时需要注意的是，一旦定义了取值函数get（或存值函数set），"),r("em",[r("strong",[e._v("就不能将writable设为true")])]),e._v("，或者***同时定义value属性***，"),r("em",[r("strong",[e._v("会报错")])]),e._v("。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {};\n\nObject.defineProperty(o, 'p', {\n  value: 123,\n  get: function() { return 456; }\n});\n//上面代码同时定义了get属性和value属性，结果就报错。\n// TypeError: Invalid property.  无效的属性\n// A property cannot both have accessors and be writable or have a value,  一个属性不能同时有访问器和可写值或者value值\n")])])]),r("h5",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),r("p",[r("code",[e._v("Object.defineProperty()")]),e._v("和 "),r("code",[e._v("Object.defineProperties()")]),e._v("的第三个参数，是一个属性对象。它的 "),r("code",[e._v("writable、configurable、enumerable")]),e._v("这三个属性的默认值都为false")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-csharp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {};\n\nObject.defineProperty(o, 'p', {\n  value: \"bar\"\n});\n\no.p // bar\n\no.p = 'foobar';\no.p // bar\n\nObject.defineProperty(o, 'p', {\n  value: 'foobar',\n});\n// TypeError: Cannot redefine property: p 不能重新定义P属性；\n")])])]),r("p",[e._v("上面代码由于 "),r("code",[e._v("writable")]),e._v("属性默认为 "),r("code",[e._v("false")]),e._v("，导致无法对p属性重新赋值；")]),e._v(" "),r("p",[r("code",[e._v("configurable")]),e._v("属性为 "),r("code",[e._v("false")]),e._v("，将无法删除该属性，也无法修改 "),r("code",[e._v("attributes")]),e._v("对象（"),r("code",[e._v("value")]),e._v("属性除外）。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {};\n\nObject.defineProperty(o, 'p', {\n  value: 'bar',\n});\n\ndelete o.p\no.p // \"bar\"\n")])])]),r("p",[e._v("上面代码中，由于configurable属性默认为false，导致无法删除某个属性。")]),e._v(" "),r("p",[r("code",[e._v("enumerable")]),e._v("属性为 "),r("code",[e._v("false")]),e._v("，表示对应的属性不会出现在 "),r("code",[e._v("for...in")]),e._v("循环和 "),r("code",[e._v("Object.keys")]),e._v("方法中。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {\n  p1: 10,\n  p2: 13,\n};\n\nObject.defineProperty(o, 'p3', {\n  value: 3,\n});\n\nfor (var i in o) {\n  console.log(i, o[i]);\n}\n// p1 10\n// p2 13\n")])])]),r("p",[e._v("上面代码中，p3属性是用 "),r("code",[e._v("Object.defineProperty")]),e._v("方法定义的，由于 "),r("code",[e._v("enumerable")]),e._v("属性默认为 "),r("code",[e._v("false")]),e._v("，所以不出现在 "),r("code",[e._v("for...in")]),e._v("循环中。")]),e._v(" "),r("p",[e._v("可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。")]),e._v(" "),r("ul",[r("li",[e._v("for..in循环")]),e._v(" "),r("li",[e._v("Object.keys方法")]),e._v(" "),r("li",[e._v("JSON.stringify方法***因此，enumerable可以用来设置“秘密”属性。***")])]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('var o = {a: 1, b: 2};\n\no.c = 3;\nObject.defineProperty(o, \'d\', {\n  value: 4,\n  enumerable: false\n});\n\no.d // 4\n\nfor (var key in o) {\n  console.log(o[key]);\n}\n// 1\n// 2\n// 3\n\nObject.keys(o)  // ["a", "b", "c"]\n\nJSON.stringify(o) // "{a:1, b:2, c:3}"\n')])])]),r("p",[e._v("上面代码中，d属性的 "),r("code",[e._v("enumerable")]),e._v("为 "),r("code",[e._v("false")]),e._v("，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。")]),e._v(" "),r("h5",{attrs:{id:"基本上-javascript原生提供的属性都是不可枚举的-用户自定义的属性都是可枚举的。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本上-javascript原生提供的属性都是不可枚举的-用户自定义的属性都是可枚举的。"}},[e._v("#")]),e._v(" 基本上，JavaScript原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。")]),e._v(" "),r("p",[r("strong",[e._v("可配置性（configurable）")])]),e._v(" "),r("p",[e._v("可配置性（configurable）决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-dart extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = Object.defineProperty({}, 'p', {\n  value: 1,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nObject.defineProperty(o,'p', {value: 2})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperty(o,'p', {writable: true})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperty(o,'p', {enumerable: true})\n// TypeError: Cannot redefine property: p\n\nObject.defineProperties(o,'p',{configurable: true})\n// TypeError: Cannot redefine property: p\n")])])]),r("p",[e._v("上面代码首先定义对象o，并且定义o的属性p的configurable为false。然后，逐一改动value、writable、enumerable、configurable，结果都报错。")]),e._v(" "),r("p",[r("strong",[e._v("存取器（accessor）")])]),e._v(" "),r("p",[e._v("除了直接定义以外，属性还可以用存取器（accessor）定义。")]),e._v(" "),r("blockquote"),e._v(" "),r("blockquote",[r("p",[e._v("其中:")]),e._v(" "),r("p",[e._v("存值函数称为setter，使用set命令；")]),e._v(" "),r("p",[e._v("取值函数称为getter，使用get命令。")])]),e._v(" "),r("p",[e._v("存取器提供的是"),r("strong",[e._v("虚拟属性")]),e._v("，即该属性的值不是实际存在的，而是每次读取时计算生成的。利用这个功能，可以实现许多高级特性，比如每个属性禁止赋值。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-csharp extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {\n  get p() {\n    return 'getter';\n  },\n  set p(value) {\n    console.log('setter: ' + value);\n  }\n};\no.p // \"getter\"\no.p = 123 // \"setter: 123\"\n")])])]),r("p",[e._v("注意，取值函数Getter不能接受参数，存值函数Setter只能接受一个参数（即属性的值）。另外，对象也不能有与取值函数同名的属性。比如，上面的对象o设置了取值函数p以后，就不能再另外定义一个p属性。")]),e._v(" "),r("p",[e._v("利用存取器，可以实现数据对象与DOM对象的双向绑定。")]),e._v(" "),r("p",[e._v("**")]),e._v(" "),r("div",{staticClass:"language-e-jsx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Object.defineProperty(user, 'name', {\n  get: function () {\n    return document.getElementById('foo').value;\n  },\n  set: function (newValue) {\n    document.getElementById('foo').value = newValue;\n  },\n  configurable: true\n});\n")])])]),r("p",[e._v("上面代码使用存取函数，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。")]),e._v(" "),r("p",[e._v("文章来源：https://www.jianshu.com/p/e9b1028ca323")]),e._v(" "),r("backTop")],1)}),[],!1,null,null,null);t.default=a.exports}}]);