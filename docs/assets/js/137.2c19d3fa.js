(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{420:function(t,n,e){"use strict";e.r(n);var r=e(10),i=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"万字扫盲bytebuffer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#万字扫盲bytebuffer"}},[t._v("#")]),t._v(" 万字扫盲ByteBuffer")]),t._v(" "),e("h1",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("已知"),e("strong",[t._v("NIO")]),t._v("中有三大组件："),e("strong",[t._v("Channel")]),t._v("，"),e("strong",[t._v("Buffer")]),t._v("和"),e("strong",[t._v("Selector")]),t._v("。那么"),e("strong",[t._v("Buffer")]),t._v("的作用就是提供一个缓冲区，用于用户程序和"),e("strong",[t._v("Channel")]),t._v("之间进行数据读写，也就是用户程序中可以使用"),e("strong",[t._v("Buffer")]),t._v("向"),e("strong",[t._v("Channel")]),t._v("写入数据，也可以使用"),e("strong",[t._v("Buffer")]),t._v("从"),e("strong",[t._v("Channel")]),t._v("读取数据。")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("是"),e("strong",[t._v("Buffer")]),t._v("子类，是字节缓冲区，特点如下所示。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("大小不可变")]),t._v("。一旦创建，无法改变其容量大小，无法扩容或者缩容；")]),t._v(" "),e("li",[e("strong",[t._v("读写灵活")]),t._v("。内部通过指针移动来实现灵活读写；")]),t._v(" "),e("li",[t._v("支持"),e("strong",[t._v("堆上")]),t._v("内存分配和"),e("strong",[t._v("直接")]),t._v("内存分配。")])]),t._v(" "),e("p",[t._v("本文将对"),e("strong",[t._v("ByteBuffer")]),t._v("的相关概念，常用"),e("strong",[t._v("API")]),t._v("以及使用案例进行分析。全文约1万字，知识点脑图如下。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/45e97791909d4f91ab82942f8fd84fd0~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=B4nEzyjPUm5tCY%2Fk5TISy47dzUs%3D",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"正文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),e("h1",{attrs:{id:"一-buffer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-buffer"}},[t._v("#")]),t._v(" 一. Buffer")]),t._v(" "),e("p",[t._v("在"),e("strong",[t._v("NIO")]),t._v("中，八大基础数据类型中除了"),e("strong",[t._v("boolean")]),t._v("外，都有相应的"),e("strong",[t._v("Buffer")]),t._v("的实现，类图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/2bce4fe84f78458ea1a32f3f10856a43~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=mOyWzbkcOzQJys4kotNCb8Sq5HI%3D",alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("Buffer")]),t._v("类对各种基础数据类型的缓冲区做了顶层抽象，所以要了解"),e("strong",[t._v("ByteBuffer")]),t._v("，首先应该学习"),e("strong",[t._v("Buffer")]),t._v("类。")]),t._v(" "),e("h1",{attrs:{id:"_1-buffer的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-buffer的属性"}},[t._v("#")]),t._v(" 1. Buffer的属性")]),t._v(" "),e("p",[t._v("所有缓冲区结构都有如下属性。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("int position")])]),t._v(" "),e("td",[t._v("位置索引。代表下一次将要操作的元素的位置，默认初始为0，位置索引最小为0，最大为"),e("strong",[t._v("limit")])])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("int limit")])]),t._v(" "),e("td",[t._v("限制索引。限制索引及之后的索引位置上的元素都不能操作，限制索引最小为0，最大为"),e("strong",[t._v("capacity")])])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("int capacity")])]),t._v(" "),e("td",[t._v("容量。缓冲区的最大元素个数，创建缓冲区时指定，最小为0，不能改变")])])])]),t._v(" "),e("p",[t._v("三者之间的大小关系应该是："),e("strong",[t._v("0 <= position <= limit <= capacity")]),t._v("，图示如下。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/15836968e10a4b4f91fe4b7de019baa4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=ZXSx2FfZAEgoiYvlL9GLzAawMzM%3D",alt:""}})]),t._v(" "),e("p",[t._v("除此之外，还有一个属性叫做"),e("strong",[t._v("mark")]),t._v("，如下所示。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("int mark")])]),t._v(" "),e("td",[t._v("标记索引。"),e("strong",[t._v("mark")]),t._v("会标记一个索引，在"),e("strong",[t._v("Buffer#reset")]),t._v("调用时，将"),e("strong",[t._v("position")]),t._v("重置为"),e("strong",[t._v("mark")]),t._v("。"),e("strong",[t._v("mark")]),t._v("不是必须的，但是当定义"),e("strong",[t._v("mark")]),t._v("后，其最小为0，最大为"),e("strong",[t._v("position")])])])])]),t._v(" "),e("p",[t._v("关于"),e("strong",[t._v("mark")]),t._v("还有如下两点说明。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("position")]),t._v("或"),e("strong",[t._v("limit")]),t._v("一旦小于"),e("strong",[t._v("mark")]),t._v("则"),e("strong",[t._v("mark")]),t._v("会被丢弃；")]),t._v(" "),e("li",[t._v("没有定义"),e("strong",[t._v("mark")]),t._v("时如果调用了"),e("strong",[t._v("Buffer#reset")]),t._v("则会抛出"),e("strong",[t._v("InvalidMarkException")]),t._v("。")])]),t._v(" "),e("h1",{attrs:{id:"_2-buffer的读模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-buffer的读模式"}},[t._v("#")]),t._v(" 2. Buffer的读模式")]),t._v(" "),e("p",[e("strong",[t._v("Buffer")]),t._v("有两种模式，读模式和写模式，在读模式下，可以读取缓冲区中的数据。那么对于一个缓冲区，要读取数据时，分为两步。")]),t._v(" "),e("ol",[e("li",[t._v("拿到"),e("strong",[t._v("position")]),t._v("位置索引；")]),t._v(" "),e("li",[t._v("取"),e("strong",[t._v("position")]),t._v("位置的数据。")])]),t._v(" "),e("p",[t._v("那么"),e("strong",[t._v("Buffer")]),t._v("提供了"),e("strong",[t._v("nextGetIndex()")]),t._v(" 方法和"),e("strong",[t._v("nextGetIndex(int nb)")]),t._v(" 方法来获取"),e("strong",[t._v("position")]),t._v("，先看一下"),e("strong",[t._v("nextGetIndex()")]),t._v(" 方法的实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("final int nextGetIndex() {\n    // limit位置是不可操作的\n    if (position >= limit) {\n        throw new BufferUnderflowException();\n    }\n    // 返回当前position\n    // 然后position后移一个位置\n    return position++;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("nextGetIndex()")]),t._v(" 方法首先校验一下"),e("strong",[t._v("position")]),t._v("是否大于等于"),e("strong",[t._v("limit")]),t._v("，因为"),e("strong",[t._v("limit")]),t._v("及之后的位置都是不可操作的，所以只要满足"),e("strong",[t._v("position")]),t._v("大于等于"),e("strong",[t._v("limit")]),t._v("则抛出异常，然后返回当前的"),e("strong",[t._v("position")]),t._v("（也就是当前可操作的位置），最后"),e("strong",[t._v("position")]),t._v("后移一位。")]),t._v(" "),e("p",[t._v("而"),e("strong",[t._v("nextGetIndex(int nb)")]),t._v(" 方法，则是用于"),e("strong",[t._v("Buffer")]),t._v("的子类"),e("strong",[t._v("ByteBuffer")]),t._v("使用，因为"),e("strong",[t._v("ByteBuffer")]),t._v("的一个元素就是一个字节，而如果想要通过"),e("strong",[t._v("ByteBuffer")]),t._v("获取一个整形数据，那么此时就需要连续读取四个字节。"),e("strong",[t._v("nextGetIndex(int nb)")]),t._v(" 方法如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("final int nextGetIndex(int nb) {\n    // 判断一下剩余可操作元素是否够本次获取\n    if (limit - position < nb) {\n        throw new BufferUnderflowException();\n    }\n    // 暂存当前position\n    int p = position;\n    // 然后position后移nb个位置\n    position += nb;\n    // 返回暂存的position\n    return p;\n}\n复制代码\n")])])]),e("p",[t._v("拿到"),e("strong",[t._v("position")]),t._v("后，实际的读取数据，由"),e("strong",[t._v("Buffer")]),t._v("的子类来实现。")]),t._v(" "),e("h1",{attrs:{id:"_3-buffer的写模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-buffer的写模式"}},[t._v("#")]),t._v(" 3. Buffer的写模式")]),t._v(" "),e("p",[t._v("有读就有写，在"),e("strong",[t._v("Buffer")]),t._v("的写模式下，写入数据也是分为两步。")]),t._v(" "),e("ol",[e("li",[t._v("拿到"),e("strong",[t._v("position")]),t._v("位置索引；")]),t._v(" "),e("li",[t._v("写入数据到"),e("strong",[t._v("position")]),t._v("位置。")])]),t._v(" "),e("p",[t._v("写模式下，"),e("strong",[t._v("Buffer")]),t._v("同样为获取"),e("strong",[t._v("position")]),t._v("提供了两个方法，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("final int nextPutIndex() {\n    // limit位置是不可操作的\n    if (position >= limit) {\n        throw new BufferOverflowException();\n    }\n    // 返回当前position\n    // 然后position后移一个位置\n    return position++;\n}\n\nfinal int nextPutIndex(int nb) {\n    // 判断一下剩余可操作元素是否够本次写入\n    if (limit - position < nb) {\n        throw new BufferOverflowException();\n    }\n    // 暂存当前position\n    int p = position;\n    // 然后position后移nb个位置\n    position += nb;\n    // 返回暂存的position\n    return p;\n}\n复制代码\n")])])]),e("p",[t._v("同样，拿到"),e("strong",[t._v("position")]),t._v("后，实际的写入数据，由"),e("strong",[t._v("Buffer")]),t._v("的子类来实现。")]),t._v(" "),e("h1",{attrs:{id:"_4-buffer读写模式切换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-buffer读写模式切换"}},[t._v("#")]),t._v(" 4. Buffer读写模式切换")]),t._v(" "),e("p",[e("strong",[t._v("Buffer")]),t._v("提供了读模式和写模式，同一时间"),e("strong",[t._v("Buffer")]),t._v("只能在同一模式下工作，相应的，"),e("strong",[t._v("Buffer")]),t._v("提供了对应的方法来做读写模式切换。")]),t._v(" "),e("p",[t._v("首先是读模式切换到写模式，先看如下示意图。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3b30b8cca9eb4832875e342c44d12484~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=7EL5AI8tGCZWmfVj9DLYI579zKY%3D",alt:""}})]),t._v(" "),e("p",[t._v("上图中的情况是缓冲区中的数据已经全部被读完，那么此时如果要切换到写模式，对应的方法是"),e("strong",[t._v("clear()")]),t._v(" 方法，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public final Buffer clear() {\n    // 重置position为0\n    position = 0;\n    // 设置limit为capacity\n    limit = capacity;\n    // 重置mark为-1\n    mark = -1;\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("注意，虽然方法名叫做"),e("strong",[t._v("clear()")]),t._v("，但是实际缓冲区中的数据并没有被清除，而只是将位置索引"),e("strong",[t._v("position")]),t._v("，限制索引"),e("strong",[t._v("limit")]),t._v("进行了重置，同时清除了标记状态（也就是将"),e("strong",[t._v("mark")]),t._v("设置为-1）。切换到写模式后，缓冲区示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/8cff77a5369d4ec9bcdb61ee6648ecb5~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=umtxpJM3tqJ2ehPmJKx4IuXNGL4%3D",alt:""}})]),t._v(" "),e("p",[t._v("然后是写模式切换到读模式，先看如下示意图。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/4b82c36a633b428ba277697192817c96~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=GT7e6o6b6KbRLq4bcdCJIQBPYWY%3D",alt:""}})]),t._v(" "),e("p",[t._v("数据已经写入完毕了，此时如果要切换到读模式，对应的方法是"),e("strong",[t._v("flip()")]),t._v("，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public final Buffer flip() {\n    // 因为position位置还没写入数据\n    // 所以将position位置设置为limit\n    limit = position;\n    // 重置position为0\n    position = 0;\n    // 重置mark为-1\n    mark = -1;\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("因为"),e("strong",[t._v("position")]),t._v("永远代表下一个可操作的位置，那么在写模式下，"),e("strong",[t._v("position")]),t._v("代表下一个写入的位置，那么其实就还没有数据写入，所以调用"),e("strong",[t._v("flip()")]),t._v(" 方法后，首先将"),e("strong",[t._v("position")]),t._v("位置设置为"),e("strong",[t._v("limit")]),t._v("，表示数据最多读取到"),e("strong",[t._v("limit")]),t._v("的上一个位置，然后重置"),e("strong",[t._v("position")]),t._v("和"),e("strong",[t._v("mark")]),t._v("。切换到读模式后，缓冲区示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/4bff3d65a5844bf180e7dc6a68af2694~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=9mtsYULArmVxs5n2FDtajeLCrLs%3D",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"_5-buffer的rewind操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-buffer的rewind操作"}},[t._v("#")]),t._v(" 5. Buffer的rewind操作")]),t._v(" "),e("p",[t._v("在使用"),e("strong",[t._v("Buffer")]),t._v("时，可以针对已经操作的区域进行重操作，假设缓冲区示意图如下。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e996f05ed4094154b66ed45a95041dc8~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=spQjoHtUpgTk2MfQ40dBOO9J6e8%3D",alt:""}})]),t._v(" "),e("p",[t._v("再看一下"),e("strong",[t._v("rewind()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public final Buffer rewind() {\n    // 重置position为0\n    position = 0;\n    // 清除mark\n    mark = -1;\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("主要就是将位置索引"),e("strong",[t._v("position")]),t._v("重置为0，这样就能重新操作已经操作过的位置了，同时如果启用了"),e("strong",[t._v("mark")]),t._v("，那么还会清除"),e("strong",[t._v("mark")]),t._v("，也就是重置"),e("strong",[t._v("mark")]),t._v("为-1。"),e("strong",[t._v("rewind()")]),t._v(" 方法调用后的缓冲区示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e2815b7d31824fb7a89cf9010f469771~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=F5zWj5GGMZzToo%2BP6oy7ATv4Bt8%3D",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"_6-buffer的reset操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-buffer的reset操作"}},[t._v("#")]),t._v(" 6. Buffer的reset操作")]),t._v(" "),e("p",[t._v("在使用"),e("strong",[t._v("Buffer")]),t._v("时，可以启用"),e("strong",[t._v("mark")]),t._v("来标记一个已经操作过的位置，假设缓冲区示意图如下。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/547ee76bbf284198a0d3dea982471705~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=VEEwZzRHepZPQPMF3T9Hj1CK8po%3D",alt:""}})]),t._v(" "),e("p",[t._v("再看一下"),e("strong",[t._v("reset()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public final Buffer reset() {\n    int m = mark;\n    // 只要启用mark那么mark就不能为负数\n    if (m < 0) {\n        throw new InvalidMarkException();\n    }\n    // 将position重置为mark\n    position = m;\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("在没有启用"),e("strong",[t._v("mark")]),t._v("时，"),e("strong",[t._v("mark")]),t._v("为-1，只要启用了"),e("strong",[t._v("mark")]),t._v("，那么"),e("strong",[t._v("mark")]),t._v("就不能为负数。在"),e("strong",[t._v("reset()")]),t._v(" 中主要就是将位置索引"),e("strong",[t._v("position")]),t._v("重新设置到"),e("strong",[t._v("mark")]),t._v("标记的位置，以实现对"),e("strong",[t._v("mark")]),t._v("标记的位置及之后的位置进行重新操作。"),e("strong",[t._v("reset()")]),t._v(" 方法调用后的缓冲区示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7f7a7b1548ff47ca8f57b37839ae353b~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=3dEs4WvUOlmHT%2FIa79Nhh5m5Y%2F4%3D",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"二-bytebuffer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-bytebuffer"}},[t._v("#")]),t._v(" 二. ByteBuffer")]),t._v(" "),e("p",[t._v("在上一节主要对"),e("strong",[t._v("Buffer")]),t._v("进行了一个说明，那么本节会在上一节的基础上，对"),e("strong",[t._v("ByteBuffer")]),t._v("及其实现进行学习。")]),t._v(" "),e("h1",{attrs:{id:"_1-bytebuffer的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-bytebuffer的属性"}},[t._v("#")]),t._v(" 1. ByteBuffer的属性")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("相较于"),e("strong",[t._v("Buffer")]),t._v("，多了如下三个属性。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("byte[] hb")])]),t._v(" "),e("td",[t._v("字节数组。仅"),e("strong",[t._v("HeapByteBuffer")]),t._v("会使用到，"),e("strong",[t._v("HeapByteBuffer")]),t._v("的数据存储在"),e("strong",[t._v("hb")]),t._v("中")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("int offset")])]),t._v(" "),e("td",[t._v("偏移量。仅"),e("strong",[t._v("HeapByteBuffer")]),t._v("会使用到，后面会详细说明")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("isReadOnly")])]),t._v(" "),e("td",[t._v("是否只读。仅"),e("strong",[t._v("HeapByteBuffer")]),t._v("会使用到，后面会详细说明")])])])]),t._v(" "),e("p",[e("strong",[t._v("NIO")]),t._v("中为"),e("strong",[t._v("ByteBuffer")]),t._v("分配内存时，可以有两种方式。")]),t._v(" "),e("ol",[e("li",[t._v("在堆上分配内存，此时得到"),e("strong",[t._v("HeapByteBuffer")]),t._v("；")]),t._v(" "),e("li",[t._v("在直接内存中分配内存，此时得到"),e("strong",[t._v("DirectByteBuffer")]),t._v("。")])]),t._v(" "),e("p",[t._v("类图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/77c7f42dd37a49c3a786e2f748f9fc03~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=U9bVLee7CLTR9D7nofYEf2bbeIw%3D",alt:""}})]),t._v(" "),e("p",[t._v("因为"),e("strong",[t._v("DirectByteBuffer")]),t._v("是分配在直接内存中，肯定无法像"),e("strong",[t._v("HeapByteBuffer")]),t._v("一样将数据存储在字节数组，所以"),e("strong",[t._v("DirectByteBuffer")]),t._v("会通过一个"),e("strong",[t._v("address")]),t._v("字段来标识数据所在直接内存的开始地址。"),e("strong",[t._v("address")]),t._v("字段定义在"),e("strong",[t._v("Buffer")]),t._v("中，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("long address;\n复制代码\n")])])]),e("h1",{attrs:{id:"_2-bytebuffer的创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-bytebuffer的创建"}},[t._v("#")]),t._v(" 2. ByteBuffer的创建")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("提供了如下四个方法用于创建"),e("strong",[t._v("ByteBuffer")]),t._v("，如下所示。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("方法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("allocate(int capacity)")])]),t._v(" "),e("td",[t._v("在堆上分配一个新的字节缓冲区。说明如下："),e("br"),t._v("1. 创建出来后，"),e("strong",[t._v("position")]),t._v("为0，并且"),e("strong",[t._v("limit")]),t._v("会取值为"),e("strong",[t._v("capacity")]),t._v("；"),e("br"),t._v("2. 创建出来的实际为"),e("strong",[t._v("HeapByteBuffer")]),t._v("，其内部使用一个字节数组"),e("strong",[t._v("hb")]),t._v("存储元素；"),e("br"),t._v("3. 初始时"),e("strong",[t._v("hb")]),t._v("中所有元素为0")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("allocateDirect(int capacity)")])]),t._v(" "),e("td",[t._v("在直接内存中分配一个新的字节缓冲区。说明如下："),e("br"),t._v("1. 创建出来后，"),e("strong",[t._v("position")]),t._v("为0，并且"),e("strong",[t._v("limit")]),t._v("会取值为"),e("strong",[t._v("capacity")]),t._v("；"),e("br"),t._v("2. 创建出来的实际为"),e("strong",[t._v("DirectByteBuffer")]),t._v("，是基于操作系统创建的内存区域作为缓冲区；"),e("br"),t._v("3. 初始时所有元素为0")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("wrap(byte[] array)")])]),t._v(" "),e("td",[t._v("将字节数组包装到字节缓冲区中。说明如下："),e("br"),t._v("1. 创建出来的是"),e("strong",[t._v("HeapByteBuffer")]),t._v("，其内部的"),e("strong",[t._v("hb")]),t._v("字节数组就会使用传入的"),e("strong",[t._v("array")]),t._v("；"),e("br"),t._v("2. 改变"),e("strong",[t._v("HeapByteBuffer")]),t._v("会影响"),e("strong",[t._v("array")]),t._v("，改变"),e("strong",[t._v("array")]),t._v("会影响"),e("strong",[t._v("HeapByteBuffer")]),t._v("；"),e("br"),t._v("3. 得到的"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("limit")]),t._v("和"),e("strong",[t._v("capacity")]),t._v("均取值为"),e("strong",[t._v("array.length")]),t._v("；"),e("br"),t._v("4. "),e("strong",[t._v("position")]),t._v("此时都为0")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("wrap(byte[] array, int off, int length)")])]),t._v(" "),e("td",[t._v("将字节数组包装到字节缓冲区，说明如下。"),e("br"),t._v("1. 创建出来的是"),e("strong",[t._v("HeapByteBuffer")]),t._v("，其内部的"),e("strong",[t._v("hb")]),t._v("字节数组就会使用传入的"),e("strong",[t._v("array")]),t._v("；"),e("br"),t._v("2. 改变"),e("strong",[t._v("HeapByteBuffer")]),t._v("会影响"),e("strong",[t._v("array")]),t._v("，改变"),e("strong",[t._v("array")]),t._v("会影响"),e("strong",[t._v("HeapByteBuffer")]),t._v("；"),e("br"),t._v("3. "),e("strong",[t._v("capacity")]),t._v("取值为"),e("strong",[t._v("array.length")]),t._v("；"),e("br"),t._v("4. "),e("strong",[t._v("limit")]),t._v("取值为"),e("strong",[t._v("off + length")]),t._v("；"),e("br"),t._v("5. "),e("strong",[t._v("position")]),t._v("取值为"),e("strong",[t._v("off")])])])])]),t._v(" "),e("p",[t._v("下面结合源码，分析一下上述四种创建方式。")]),t._v(" "),e("p",[t._v("首先是"),e("strong",[t._v("allocate(int capacity)")]),t._v("，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static ByteBuffer allocate(int capacity) {\n    if (capacity < 0) {\n        throw new IllegalArgumentException();\n    }\n    // 直接创建HeapByteBuffer\n    // HeapByteBuffer(int cap, int lim)\n    return new HeapByteBuffer(capacity, capacity);\n}\n复制代码\n")])])]),e("p",[t._v("然后是"),e("strong",[t._v("allocateDirect(int capacity)")]),t._v("，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static ByteBuffer allocateDirect(int capacity) {\n    return new DirectByteBuffer(capacity);\n}\n\nDirectByteBuffer(int cap) {\n    // MappedByteBuffer(int mark, int pos, int lim, int cap)\n    super(-1, 0, cap, cap);\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n        // 分配堆外内存\n        base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n        Bits.unreserveMemory(size, cap);\n        throw x;\n    }\n    unsafe.setMemory(base, size, (byte) 0);\n    // 计算堆外内存起始地址\n    if (pa && (base % ps != 0)) {\n        address = base + ps - (base & (ps - 1));\n    } else {\n        address = base;\n    }\n    // 通过虚引用的手段来监视DirectByteBuffer是否被垃圾回收\n    // 从而可以及时的释放堆外内存空间\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n}\n复制代码\n")])])]),e("p",[t._v("然后是"),e("strong",[t._v("wrap(byte[] array)")]),t._v("，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static ByteBuffer wrap(byte[] array) {\n    return wrap(array, 0, array.length);\n}\n复制代码\n")])])]),e("p",[t._v("其实"),e("strong",[t._v("wrap(byte[] array)")]),t._v(" 方法就是调用的"),e("strong",[t._v("wrap(byte[] array, int off, int length)")]),t._v("，下面直接看"),e("strong",[t._v("wrap(byte[] array, int off, int length)")]),t._v(" 方法的实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static ByteBuffer wrap(byte[] array, int off, int length) {\n    try {\n        return new HeapByteBuffer(array, off, length);\n    } catch (IllegalArgumentException x) {\n        throw new IndexOutOfBoundsException();\n    }\n}\n复制代码\n")])])]),e("p",[t._v("这里先简单说明一下上述方法中的"),e("strong",[t._v("off")]),t._v("和"),e("strong",[t._v("length")]),t._v("这两个参数的含义。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("off")]),t._v("就是表示字节数组封装到字节缓冲区后，"),e("strong",[t._v("position")]),t._v("的位置，所以有"),e("strong",[t._v("position = off")]),t._v("；")]),t._v(" "),e("li",[e("strong",[t._v("length")]),t._v("简单理解就是用于计算"),e("strong",[t._v("limit")]),t._v("，即"),e("strong",[t._v("limit = position + length")]),t._v("。其实"),e("strong",[t._v("length")]),t._v("是理解为字节数组封装到字节缓冲区后，要使用的字节数组的长度。")])]),t._v(" "),e("p",[t._v("下面给出一张"),e("strong",[t._v("wrap(byte[] array, int off, int length)")]),t._v(" 方法的作用示意图。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7a45c355b5c2441e8e4c95639f2b8a54~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=qYDpoAraEFkdP1knzgQVfUpE6SA%3D",alt:""}})]),t._v(" "),e("p",[t._v("最后说明一点，无论是"),e("strong",[t._v("wrap(byte[] array)")]),t._v(" 还是"),e("strong",[t._v("wrap(byte[] array, int off, int length)")]),t._v(" 方法，均构造的是"),e("strong",[t._v("HeapByteBuffer")]),t._v("。")]),t._v(" "),e("h1",{attrs:{id:"_3-bytebuffer的slice操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-bytebuffer的slice操作"}},[t._v("#")]),t._v(" 3. ByteBuffer的slice操作")]),t._v(" "),e("p",[t._v("在"),e("strong",[t._v("ByteBuffer")]),t._v("中定义了一个抽象方法叫做"),e("strong",[t._v("slice()")]),t._v("，用于在已有的"),e("strong",[t._v("ByteBuffer")]),t._v("上得到一个新的"),e("strong",[t._v("ByteBuffer")]),t._v("，两个"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("，"),e("strong",[t._v("limit")]),t._v("，"),e("strong",[t._v("capacity")]),t._v("和"),e("strong",[t._v("mark")]),t._v("都是独立的，但是底层存储数据的内存区域是一样的，那么相应的，对其中任何一个"),e("strong",[t._v("ByteBuffer")]),t._v("做更改，会影响到另外一个"),e("strong",[t._v("ByteBuffer")]),t._v("。")]),t._v(" "),e("p",[t._v("下面先看一下"),e("strong",[t._v("HeapByteBuffer")]),t._v("对"),e("strong",[t._v("slice()")]),t._v(" 方法的实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer slice() {\n    return new HeapByteBuffer(hb, -1, 0, this.remaining(), this.remaining(), this.position() + offset);\n}\n\npublic final int remaining() {\n    return limit - position;\n}\n\nprotected HeapByteBuffer(byte[] buf, int mark, int pos, int lim, int cap, int off) {\n    super(mark, pos, lim, cap, buf, off);\n}\n\nByteBuffer(int mark, int pos, int lim, int cap,\n           byte[] hb, int offset) {\n    super(mark, pos, lim, cap);\n    this.hb = hb;\n    this.offset = offset;\n}\n复制代码\n")])])]),e("p",[t._v("新的"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("mark")]),t._v("重置为了-1，"),e("strong",[t._v("position")]),t._v("重置为了0，"),e("strong",[t._v("limit")]),t._v("等于"),e("strong",[t._v("capacity")]),t._v("等于老的"),e("strong",[t._v("HeapByteBuffer")]),t._v("的未操作数据的长度（老的"),e("strong",[t._v("limit - posittion")]),t._v("）。")]),t._v(" "),e("p",[t._v("此外，两个"),e("strong",[t._v("HeapByteBuffer")]),t._v("存储数据的字节数组"),e("strong",[t._v("hb")]),t._v("是同一个，且新的"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("offset")]),t._v("等于老的"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("，什么意思呢，先看下面这张图。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/2a8cf973036942ed8ef7ccd86ddd0983~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=zHI%2BMssFgvf2G2YJHz52cOHgU%2FU%3D",alt:""}})]),t._v(" "),e("p",[t._v("意思就是，在新的"),e("strong",[t._v("HeapByteBuffer")]),t._v("中，操作"),e("strong",[t._v("position")]),t._v("位置的元素，实际是在操作"),e("strong",[t._v("hb[position + offset]")]),t._v(" 位置的元素，那么这里也就解释了"),e("strong",[t._v("ByteBuffer")]),t._v("中"),e("strong",[t._v("offset")]),t._v("属性的作用，就是表示要操作字节数组时的索引偏移量。")]),t._v(" "),e("p",[t._v("有了上面对"),e("strong",[t._v("HeapByteBuffer")]),t._v("的理解，那么现在再看"),e("strong",[t._v("DirectByteBuffer")]),t._v("就显得很简单了，"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("slice()")]),t._v(" 方法的实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer slice() {\n    int pos = this.position();\n    int lim = this.limit();\n    assert (pos <= lim);\n    int rem = (pos <= lim ? lim - pos : 0);\n    int off = (pos << 0);\n    assert (off >= 0);\n    return new DirectByteBuffer(this, -1, 0, rem, rem, off);\n}\n\nDirectByteBuffer(DirectBuffer db,\n                 int mark, int pos, int lim, int cap,\n                 int off) {\n    super(mark, pos, lim, cap);\n    address = db.address() + off;\n    cleaner = null;\n    att = db;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("slice()")]),t._v(" 方法的实现和"),e("strong",[t._v("HeapByteBuffer")]),t._v("差不多，只不过在"),e("strong",[t._v("HeapByteBuffer")]),t._v("中是对字节数组索引有偏移，而在"),e("strong",[t._v("DirectByteBuffer")]),t._v("中是对堆外内存地址有偏移，同时偏移量都是老的"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("的值。")]),t._v(" "),e("p",[t._v("最后针对"),e("strong",[t._v("slice()")]),t._v(" 方法，有一点小说明，在"),e("strong",[t._v("DirectByteBuffer")]),t._v("的"),e("strong",[t._v("att")]),t._v("中有这么一段注释。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("If this buffer is a view of another buffer then ...")])])]),t._v(" "),e("p",[t._v("这里提到了"),e("strong",[t._v("view")]),t._v("，翻译过来叫做视图，其实调用"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("slice()")]),t._v(" 方法，可以想象成就是为原字节缓冲区创建了一个视图，这个视图和原字节缓冲区共享同一片内存区域，但是有新的一套"),e("strong",[t._v("mark")]),t._v("，"),e("strong",[t._v("position")]),t._v("，"),e("strong",[t._v("limit")]),t._v("和"),e("strong",[t._v("capacity")]),t._v("。")]),t._v(" "),e("h1",{attrs:{id:"_4-bytebuffer的asreadonlybuffer操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-bytebuffer的asreadonlybuffer操作"}},[t._v("#")]),t._v(" 4. ByteBuffer的asReadOnlyBuffer操作")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("定义了一个抽象方法叫做"),e("strong",[t._v("asReadOnlyBuffer()")]),t._v("，会在当前"),e("strong",[t._v("ByteBuffer")]),t._v("基础上创建一个新的"),e("strong",[t._v("ByteBuffer")]),t._v("，创建出来的"),e("strong",[t._v("ByteBuffer")]),t._v("能看见老"),e("strong",[t._v("ByteBuffer")]),t._v("的数据（共享同一块内存），但只能读不能写（只读的），同时两个"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("，"),e("strong",[t._v("limit")]),t._v("，"),e("strong",[t._v("capacity")]),t._v("和"),e("strong",[t._v("mark")]),t._v("是独立的。")]),t._v(" "),e("p",[t._v("先看一下"),e("strong",[t._v("HeapByteBuffer")]),t._v("对"),e("strong",[t._v("asReadOnlyBuffer()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer asReadOnlyBuffer() {\n    return new HeapByteBufferR(hb,\n            this.markValue(),\n            this.position(),\n            this.limit(),\n            this.capacity(),\n            offset);\n}\n\nprotected HeapByteBufferR(byte[] buf,\n                          int mark, int pos, int lim, int cap,\n                          int off) {\n    super(buf, mark, pos, lim, cap, off);\n    this.isReadOnly = true;\n}\n复制代码\n")])])]),e("p",[t._v("也就是会"),e("strong",[t._v("new")]),t._v("一个"),e("strong",[t._v("HeapByteBufferR")]),t._v("出来，并且会指定其"),e("strong",[t._v("isReadOnly")]),t._v("字段为"),e("strong",[t._v("true")]),t._v("，表示只读。"),e("strong",[t._v("HeapByteBufferR")]),t._v("继承于"),e("strong",[t._v("HeapByteBuffer")]),t._v("，表示只读"),e("strong",[t._v("HeapByteBuffer")]),t._v("，"),e("strong",[t._v("HeapByteBufferR")]),t._v("重写了"),e("strong",[t._v("HeapByteBuffer")]),t._v("的所有写相关方法，并且在这些写相关方法中抛出"),e("strong",[t._v("ReadOnlyBufferException")]),t._v("异常，下面是部分写方法的示例。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(int i, byte x) {\n    throw new ReadOnlyBufferException();\n}\n\npublic ByteBuffer put(byte x) {\n    throw new ReadOnlyBufferException();\n}\n复制代码\n")])])]),e("p",[t._v("再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("asReadOnlyBuffer()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer asReadOnlyBuffer() {\n    return new DirectByteBufferR(this,\n            this.markValue(),\n            this.position(),\n            this.limit(),\n            this.capacity(),\n            0);\n}\n\nDirectByteBufferR(DirectBuffer db,\n                  int mark, int pos, int lim, int cap,\n                  int off) {\n    super(db, mark, pos, lim, cap, off);\n}\n复制代码\n")])])]),e("p",[t._v("也是会"),e("strong",[t._v("new")]),t._v("一个只读的"),e("strong",[t._v("DirectByteBufferR")]),t._v("，"),e("strong",[t._v("DirectByteBufferR")]),t._v("继承于"),e("strong",[t._v("DirectByteBuffer")]),t._v("并重写了所有写相关方法，并且在这些写相关方法中抛出"),e("strong",[t._v("ReadOnlyBufferException")]),t._v("异常。")]),t._v(" "),e("h1",{attrs:{id:"_5-bytebuffer的写操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-bytebuffer的写操作"}},[t._v("#")]),t._v(" 5. ByteBuffer的写操作")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("中定义了大量写操作相关的抽象方法，如下图所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/9e4cc933be994fc789544b63d398f2a3~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=U4SzGtsHdJeO9001GFvWm%2FCvxRU%3D",alt:""}})]),t._v(" "),e("p",[t._v("总体可以进行如下归类。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/032ae3c6c19f406291e81b85cb42c4e2~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=ZQ2UxuC1sViZCRm6tieQ49RUK9U%3D",alt:""}})]),t._v(" "),e("p",[t._v("下面将对上述部分写方法结合源码进行说明。")]),t._v(" "),e("h1",{attrs:{id:"i-put-byte"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#i-put-byte"}},[t._v("#")]),t._v(" Ⅰ. put(byte)")]),t._v(" "),e("p",[t._v("首先是最简单的"),e("strong",[t._v("put(byte)")]),t._v(" 方法，作用是往字节缓冲区的"),e("strong",[t._v("position")]),t._v("位置写入一个字节，先看一下"),e("strong",[t._v("HeapByteBuffer")]),t._v("对其的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(byte x) {\n    hb[ix(nextPutIndex())] = x;\n    return this;\n}\n\nprotected int ix(int i) {\n    return i + offset;\n}\n\n// Buffer#nextPutIndex()\nfinal int nextPutIndex() {\n    if (position >= limit) {\n        throw new BufferOverflowException();\n    }\n    return position++;\n}\n复制代码\n")])])]),e("p",[t._v("再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("put(byte)")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(byte x) {\n    unsafe.putByte(ix(nextPutIndex()), ((x)));\n    return this;\n}\n\nprivate long ix(int i) {\n    return address + ((long)i << 0);\n}\n\n// Buffer#nextPutIndex()\nfinal int nextPutIndex() {\n    if (position >= limit) {\n        throw new BufferOverflowException();\n    }\n    return position++;\n}\n复制代码\n")])])]),e("p",[t._v("都是会调用到"),e("strong",[t._v("Buffer#nextPutIndex()")]),t._v(" 方法来拿到当前的"),e("strong",[t._v("position")]),t._v("，区别是"),e("strong",[t._v("HeapByteBuffer")]),t._v("是将字节写入到堆上的数组，而"),e("strong",[t._v("DirectByteBuffer")]),t._v("是写在直接内存中。")]),t._v(" "),e("h1",{attrs:{id:"ii-put-int-byte"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ii-put-int-byte"}},[t._v("#")]),t._v(" Ⅱ. put(int, byte)")]),t._v(" "),e("p",[e("strong",[t._v("put(int, byte)")]),t._v(" 方法能够在指定位置写入一个字节，注意该方法写入字节不会改变"),e("strong",[t._v("position")]),t._v("。")]),t._v(" "),e("p",[e("strong",[t._v("HeapByteBuffer")]),t._v("对其实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(int i, byte x) {\n    hb[ix(checkIndex(i))] = x;\n    return this;\n}\n\nprotected int ix(int i) {\n    return i + offset;\n}\n\n// Buffer#checkIndex(int)\nfinal int checkIndex(int i) {\n    if ((i < 0) || (i >= limit)) {\n        throw new IndexOutOfBoundsException();\n    }\n    return i;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("put(int, byte)")]),t._v(" 方法的实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(int i, byte x) {\n    unsafe.putByte(ix(checkIndex(i)), ((x)));\n    return this;\n}\n\nprivate long ix(int i) {\n    return address + ((long) i << 0);\n}\n\n// Buffer#checkIndex(int)\nfinal int checkIndex(int i) {\n    if ((i < 0) || (i >= limit)) {\n        throw new IndexOutOfBoundsException();\n    }\n    return i;\n}\n复制代码\n")])])]),e("h1",{attrs:{id:"iii-put-byte-int-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iii-put-byte-int-int"}},[t._v("#")]),t._v(" Ⅲ. put(byte[], int, int)")]),t._v(" "),e("p",[e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法是批量的将字节数组中指定的字节写到"),e("strong",[t._v("ByteBuffer")]),t._v("。")]),t._v(" "),e("p",[e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法并不是抽象方法，在"),e("strong",[t._v("ByteBuffer")]),t._v("中定义了其实现，但同时"),e("strong",[t._v("HeapByteBuffer")]),t._v("和"),e("strong",[t._v("DirectByteBuffer")]),t._v("也都对其进行了重写。下面分别看一下其实现。")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer#put(byte[], int, int)")]),t._v(" 实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(byte[] src, int offset, int length) {\n    checkBounds(offset, length, src.length);\n    if (length > remaining()) {\n        throw new BufferOverflowException();\n    }\n    int end = offset + length;\n    // 从src的offset索引开始依次将后续的length个字节写到ByteBuffer中\n    for (int i = offset; i < end; i++) {\n        this.put(src[i]);\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("对"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法的实现是循环遍历字节数组中每一个需要写入的字节，然后调用"),e("strong",[t._v("put(byte)")]),t._v(" 方法完成写入，其中"),e("strong",[t._v("offset")]),t._v("表示从字节数组的哪一个字节开始写，"),e("strong",[t._v("length")]),t._v("表示从"),e("strong",[t._v("offset")]),t._v("开始往后的多少个字节需要写入。")]),t._v(" "),e("p",[t._v("由于"),e("strong",[t._v("ByteBuffer")]),t._v("对"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法的实现的写入效率不高，所以"),e("strong",[t._v("HeapByteBuffer")]),t._v("和"),e("strong",[t._v("DirectByteBuffer")]),t._v("都有自己的实现，先看一下"),e("strong",[t._v("HeapByteBuffer")]),t._v("对"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(byte[] src, int offset, int length) {\n    checkBounds(offset, length, src.length);\n    if (length > remaining()) {\n        throw new BufferOverflowException();\n    }\n    // 使用了native的拷贝方法来实现更高效的写入\n    System.arraycopy(src, offset, hb, ix(position()), length);\n    position(position() + length);\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("由于"),e("strong",[t._v("HeapByteBuffer")]),t._v("存储字节是存储到字节数组中，所以直接使用"),e("strong",[t._v("native")]),t._v("的"),e("strong",[t._v("arraycopy()")]),t._v(" 方法来完成字节数组的拷贝是更为高效的手段。")]),t._v(" "),e("p",[t._v("再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(byte[] src, int offset, int length) {\n    // 写入字节数大于6时使用native方法来批量写入才更高效\n    if (((long) length << 0) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n        checkBounds(offset, length, src.length);\n        int pos = position();\n        int lim = limit();\n        assert (pos <= lim);\n        int rem = (pos <= lim ? lim - pos : 0);\n        if (length > rem) {\n            throw new BufferOverflowException();\n        }\n        // 这里最终会调用到native方法Unsafe#copyMemory来批量写入\n        Bits.copyFromArray(src, arrayBaseOffset,\n                (long) offset << 0,\n                ix(pos),\n                (long) length << 0);\n        // 更新position\n        position(pos + length);\n    } else {\n        // 写入字节数小于等于6则遍历每个字节并依次写入会更高效\n        super.put(src, offset, length);\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("在"),e("strong",[t._v("DirectByteBuffer")]),t._v("的实现中，并没有直接调用到"),e("strong",[t._v("native")]),t._v("方法来批量操作直接内存，而是先做了判断：如果本次批量写入的字节数大于**\nJNI_COPY_FROM_ARRAY_THRESHOLD**（默认是"),e("strong",[t._v("6")]),t._v("），才调用"),e("strong",[t._v("native")]),t._v("方法"),e("strong",[t._v("Unsafe#copyMemory")]),t._v("来完成字节在直接内存中的批量写入，否则就还是一个字节一个字节的写入。"),e("strong",[t._v("DirectByteBuffer")]),t._v("的做法主要还是考虑到"),e("strong",[t._v("native")]),t._v("方法的调用的一个开销，比如就写入一个字节，那肯定是没有必要调用"),e("strong",[t._v("native")]),t._v("方法的。")]),t._v(" "),e("h1",{attrs:{id:"iv-put-byte"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iv-put-byte"}},[t._v("#")]),t._v(" Ⅳ. put(byte[])")]),t._v(" "),e("p",[e("strong",[t._v("put(byte[])")]),t._v(" 方法的作用是将一个字节数组的内容全部写入到"),e("strong",[t._v("ByteBuffer")]),t._v("，该方法是一个"),e("strong",[t._v("final")]),t._v("方法，所以这里看一下"),e("strong",[t._v("ByteBuffer")]),t._v("中该方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public final ByteBuffer put(byte[] src) {\n    return put(src, 0, src.length);\n}\n复制代码\n")])])]),e("p",[t._v("其实就是调用到"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法来完成批量写入。")]),t._v(" "),e("h1",{attrs:{id:"v-put-bytebuffer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-put-bytebuffer"}},[t._v("#")]),t._v(" Ⅴ. put(ByteBuffer)")]),t._v(" "),e("p",[e("strong",[t._v("put(ByteBuffer)")]),t._v(" 方法用于将一个"),e("strong",[t._v("ByteBuffer")]),t._v("中所有未操作的字节批量写入当前"),e("strong",[t._v("ByteBuffer")]),t._v("。"),e("strong",[t._v("ByteBuffer")]),t._v("，"),e("strong",[t._v("HeapByteBuffer")]),t._v("和"),e("strong",[t._v("DirectByteBuffer")]),t._v("都有相应的实现，下面分别看一下。")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer#put(ByteBuffer)")]),t._v(" 思路还是一个字节一个字节的写入，实现如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(ByteBuffer src) {\n    if (src == this) {\n        throw new IllegalArgumentException();\n    }\n    if (isReadOnly()) {\n        throw new ReadOnlyBufferException();\n    }\n    // 计算limit - position\n    int n = src.remaining();\n    if (n > remaining()) {\n        throw new BufferOverflowException();\n    }\n    // 一个字节一个字节的写入\n    for (int i = 0; i < n; i++) {\n        put(src.get());\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("HeapByteBuffer#put(ByteBuffer)")]),t._v(" 思路是先判断源"),e("strong",[t._v("ByteBuffer")]),t._v("的类型，如果源"),e("strong",[t._v("ByteBuffer")]),t._v("是"),e("strong",[t._v("HeapByteBuffer")]),t._v("，则调用"),e("strong",[t._v("native")]),t._v("方法"),e("strong",[t._v("System#arraycopy")]),t._v("完成批量写入，如果源"),e("strong",[t._v("ByteBuffer")]),t._v("是在直接内存中分配的，则再判断一下要写入的字节是否大于6，如果大于6就调用"),e("strong",[t._v("native")]),t._v("方法"),e("strong",[t._v("Unsafe#copyMemory")]),t._v("完成批量写入，否则就一个字节一个字节的写入。实现如下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(ByteBuffer src) {\n    if (src instanceof HeapByteBuffer) {\n        if (src == this) {\n            throw new IllegalArgumentException();\n        }\n        HeapByteBuffer sb = (HeapByteBuffer) src;\n        // 计算源ByteBuffer剩余的字节数\n        int n = sb.remaining();\n        if (n > remaining()) {\n            throw new BufferOverflowException();\n        }\n        // 调用native方法批量写入\n        System.arraycopy(sb.hb, sb.ix(sb.position()),\n                hb, ix(position()), n);\n        // 更新源ByteBuffer的position\n        sb.position(sb.position() + n);\n        // 更新当前ByteBuffer的position\n        position(position() + n);\n    } else if (src.isDirect()) {\n        // 计算源ByteBuffer剩余的字节数\n        int n = src.remaining();\n        if (n > remaining()) {\n            throw new BufferOverflowException();\n        }\n        // 批量写入字节到当前ByteBuffer的hb字节数组中\n        src.get(hb, ix(position()), n);\n        // 更新当前ByteBuffer的position\n        position(position() + n);\n    } else {\n        super.put(src);\n    }\n    return this;\n}\n\n// DirectByteBuffer#get(byte[], int, int)\npublic ByteBuffer get(byte[] dst, int offset, int length) {\n    if (((long) length << 0) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n        checkBounds(offset, length, dst.length);\n        int pos = position();\n        int lim = limit();\n        assert (pos <= lim);\n        int rem = (pos <= lim ? lim - pos : 0);\n        if (length > rem) {\n            throw new BufferUnderflowException();\n        }\n        Bits.copyToArray(ix(pos), dst, arrayBaseOffset,\n                (long) offset << 0,\n                (long) length << 0);\n        // 更新源ByteBuffer的position\n        position(pos + length);\n    } else {\n        super.get(dst, offset, length);\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("DirectByteBuffer#put(ByteBuffer)")]),t._v(" 的思路也是先判断源"),e("strong",[t._v("ByteBuffer")]),t._v("的类型，如果源"),e("strong",[t._v("ByteBuffer")]),t._v("是"),e("strong",[t._v("DirectByteBuffer")]),t._v("，则直接使用"),e("strong",[t._v("native")]),t._v("方法"),e("strong",[t._v("Unsafe#copyMemory")]),t._v("完成批量写入，如果源"),e("strong",[t._v("ByteBuffer")]),t._v("是在堆上分配的，则按照"),e("strong",[t._v("DirectByteBuffer")]),t._v("的"),e("strong",[t._v("put(byte[], int, int)")]),t._v(" 方法的逻辑完成批量写入。实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer put(ByteBuffer src) {\n    if (src instanceof DirectByteBuffer) {\n        if (src == this) {\n            throw new IllegalArgumentException();\n        }\n        DirectByteBuffer sb = (DirectByteBuffer) src;\n        int spos = sb.position();\n        int slim = sb.limit();\n        assert (spos <= slim);\n        // 计算源ByteBuffer剩余的字节数\n        int srem = (spos <= slim ? slim - spos : 0);\n\n        int pos = position();\n        int lim = limit();\n        assert (pos <= lim);\n        int rem = (pos <= lim ? lim - pos : 0);\n\n        if (srem > rem) {\n            throw new BufferOverflowException();\n        }\n        // 调用native方法完成批量写入\n        unsafe.copyMemory(sb.ix(spos), ix(pos), (long) srem << 0);\n        // 更新源ByteBuffer的position\n        sb.position(spos + srem);\n        // 更新当前ByteBuffer的position\n        position(pos + srem);\n    } else if (src.hb != null) {\n        int spos = src.position();\n        int slim = src.limit();\n        assert (spos <= slim);\n        // 计算源ByteBuffer剩余的字节数\n        int srem = (spos <= slim ? slim - spos : 0);\n        // 调用DirectByteBuffer#put(byte[], int, int)完成批量写入\n        put(src.hb, src.offset + spos, srem);\n        // 更新源ByteBuffer的position\n        src.position(spos + srem);\n    } else {\n        super.put(src);\n    }\n    return this;\n}\n\n// DirectByteBuffer#put(byte[], int, int)\npublic ByteBuffer put(byte[] src, int offset, int length) {\n    if (((long) length << 0) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n        checkBounds(offset, length, src.length);\n        int pos = position();\n        int lim = limit();\n        assert (pos <= lim);\n        int rem = (pos <= lim ? lim - pos : 0);\n        if (length > rem) {\n            throw new BufferOverflowException();\n        }\n        Bits.copyFromArray(src, arrayBaseOffset,\n                (long) offset << 0,\n                ix(pos),\n                (long) length << 0);\n        // 更新当前ByteBuffer的position\n        position(pos + length);\n    } else {\n        super.put(src, offset, length);\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[t._v("最后有一点需要说明，调用"),e("strong",[t._v("put(ByteBuffer)")]),t._v(" 方法完成批量字节写入后，源"),e("strong",[t._v("ByteBuffer")]),t._v("和当前"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("都会被更新。")]),t._v(" "),e("h1",{attrs:{id:"vi-字节序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vi-字节序"}},[t._v("#")]),t._v(" Ⅵ. 字节序")]),t._v(" "),e("p",[t._v("上述的几种"),e("strong",[t._v("put()")]),t._v(" 方法都是向"),e("strong",[t._v("ByteBuffer")]),t._v("写入字节，但其实也是可以直接将"),e("strong",[t._v("char")]),t._v("，"),e("strong",[t._v("int")]),t._v("等基础数据类型写入"),e("strong",[t._v("ByteBuffer")]),t._v("，但在分析这些写入基础数据类型到"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("put()")]),t._v(" 方法以前，有必要对字节序的相关概念进行演示和说明。")]),t._v(" "),e("p",[t._v("已知在"),e("strong",[t._v("Java")]),t._v("中一个"),e("strong",[t._v("int")]),t._v("是四个字节，而一个字节是8位，那么就以数字"),e("strong",[t._v("23333")]),t._v("为例，示意如下。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p26-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/710184b19a124d4b916862645f0b17aa~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=3hwzV%2FKASUD3HMiEKWvY7rQplR8%3D",alt:""}})]),t._v(" "),e("p",[t._v("那么上述的一个"),e("strong",[t._v("int")]),t._v("数据，存储在内存中时，如果高位字节存储在内存的低地址，低位字节存储在内存的高地址，这种就称为"),e("strong",[t._v("大端字节序（Big Endian）")]),t._v("，示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/904e7ab2273a44199d0d32895bf73f45~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=8Lqp0PNGIgIA1DCTrMDRRdJjanQ%3D",alt:""}})]),t._v(" "),e("p",[t._v("反之如果低位字节存储在内存的低地址，高位字节存储在内存的高地址，这种就称为"),e("strong",[t._v("小端字节序（Little Endian）")]),t._v("，示意图如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/05bd492e98664e90b0eb8fee84fc198d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=BxpROV5eQvtU%2FxWAePk7mCfwtJQ%3D",alt:""}})]),t._v(" "),e("p",[t._v("上述其实是"),e("strong",[t._v("主机字节序")]),t._v("，表示计算机内存中字节的存储顺序。在"),e("strong",[t._v("Java")]),t._v("中，数据的存储默认是按照"),e("strong",[t._v("大端字节序")]),t._v("来存储的。")]),t._v(" "),e("p",[t._v("然后还有一种叫做"),e("strong",[t._v("网络字节序")]),t._v("，表示网络传输中字节的传输顺序，分类如下。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("大端字节序（Big Endian）")]),t._v("。从二进制数据的高位开始传输；")]),t._v(" "),e("li",[e("strong",[t._v("小端字节序（Little Endian）")]),t._v("。从二进制数据的低位开始传输。")])]),t._v(" "),e("p",[t._v("在网络传输中，默认按照"),e("strong",[t._v("大端字节序")]),t._v("来传输。")]),t._v(" "),e("h1",{attrs:{id:"vii-putint-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vii-putint-int"}},[t._v("#")]),t._v(" Ⅶ. putInt(int)")]),t._v(" "),e("p",[e("strong",[t._v("putInt(int)")]),t._v(" 方法是"),e("strong",[t._v("ByteBuffer")]),t._v("定义的用于直接写入一个"),e("strong",[t._v("int")]),t._v("的抽象方法，先看"),e("strong",[t._v("HeapByteBuffer")]),t._v("的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer putInt(int x) {\n    // 通过nextPutIndex(4)方法拿到当前position，并让position加4\n    // 然后调用Bits#putInt完成写入，其中bigEndian默认是true\n    Bits.putInt(this, ix(nextPutIndex(4)), x, bigEndian);\n    return this;\n}\n\n// Bits#putInt\nstatic void putInt(ByteBuffer bb, int bi, int x, boolean bigEndian) {\n    if (bigEndian) {\n        putIntB(bb, bi, x);\n    } else {\n        putIntL(bb, bi, x);\n    }\n}\n\n// Bits#putIntB\nstatic void putIntB(ByteBuffer bb, int bi, int x) {\n    // 通过Bits#int3方法拿到x的第3字节（最高位字节）\n    // 然后写入到hb字节数组的索引为bi的位置\n    bb._put(bi    , int3(x));\n    // 通过Bits#int2方法拿到x的第2字节（次高位字节）\n    // 然后写入到hb字节数组的索引为bi+1的位置\n    bb._put(bi + 1, int2(x));\n    // 通过Bits#int1方法拿到x的第1字节（次低位字节）\n    // 然后写入到hb字节数组的索引为bi+2的位置\n    bb._put(bi + 2, int1(x));\n    // 通过Bits#int0方法拿到x的第0字节（最低位字节）\n    // 然后写入到hb字节数组的索引为bi+3的位置\n    bb._put(bi + 3, int0(x));\n}\n\n// Bits#int3\nprivate static byte int3(int x) {\n    return (byte) (x >> 24);\n}\n\n// HeapByteBuffer#_put\nvoid _put(int i, byte b) {\n    hb[i] = b;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("HeapByteBuffer")]),t._v("实现的"),e("strong",[t._v("putInt(int)")]),t._v(" 方法中，会依次将"),e("strong",[t._v("int")]),t._v("的高位到低位写入到"),e("strong",[t._v("hb")]),t._v("字节数组的低索引到高索引，而在堆中，内存地址是由低到高的，也就是随着数组索引的增加，内存地址也会逐渐增高，所以上述的就是按照大端字节序的方式来直接写入一个"),e("strong",[t._v("int")]),t._v("。")]),t._v(" "),e("p",[t._v("再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("putInt(int)")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer putInt(int x) {\n    // 通过nextPutIndex(4)方法拿到当前position，并让position加4\n    // 通过ix()方法拿到实际要写入的内存地址\n    putInt(ix(nextPutIndex((1 << 2))), x);\n    return this;\n}\n\n// DirectByteBuffer#putInt(long, int)\nprivate ByteBuffer putInt(long a, int x) {\n    if (unaligned) {\n        int y = (x);\n        unsafe.putInt(a, (nativeByteOrder ? y : Bits.swap(y)));\n    } else {\n        // 调用Bits#putInt完成写入，其中bigEndian默认是true\n        Bits.putInt(a, x, bigEndian);\n    }\n    return this;\n}\n\n// Bits#putInt\nstatic void putInt(long a, int x, boolean bigEndian) {\n    if (bigEndian) {\n        putIntB(a, x);\n    } else {\n        putIntL(a, x);\n    }\n}\n\n// Bits#putIntB\nstatic void putIntB(long a, int x) {\n    // 通过Bits#int3方法拿到x的第3字节（最高位字节）\n    // 然后写入到直接内存地址为a的位置\n    _put(a    , int3(x));\n    // 通过Bits#int2方法拿到x的第2字节（次高位字节）\n    // 然后写入到直接内存地址为a+1的位置\n    _put(a + 1, int2(x));\n    // 通过Bits#int1方法拿到x的第1字节（次低位字节）\n    // 然后写入到直接内存地址为a+2的位置\n    _put(a + 2, int1(x));\n    // 通过Bits#int0方法拿到x的第0字节（最低位字节）\n    // 然后写入到直接内存地址为a+3的位置\n    _put(a + 3, int0(x));\n}\n\n// Bits#int3\nprivate static byte int3(int x) {\n    return (byte) (x >> 24);\n}\n\n// Bits#_put\nprivate static void _put(long a, byte b) {\n    unsafe.putByte(a, b);\n}\n复制代码\n")])])]),e("p",[t._v("在"),e("strong",[t._v("DirectByteBuffer")]),t._v("的实现中，会依次将"),e("strong",[t._v("int")]),t._v("的高位到低位写入到直接内存的低地址到高地址，整体也是一个大端字节序的写入方式。")]),t._v(" "),e("h1",{attrs:{id:"viii-putint-int-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#viii-putint-int-int"}},[t._v("#")]),t._v(" Ⅷ. putInt(int, int)")]),t._v(" "),e("p",[e("strong",[t._v("putInt(int, int)")]),t._v(" 方法可以在指定位置写入"),e("strong",[t._v("int")]),t._v("，同时也不会更改"),e("strong",[t._v("position")]),t._v("。"),e("strong",[t._v("putInt(int, int)")]),t._v(" 方法实现原理和"),e("strong",[t._v("putInt(int)")]),t._v(" 一样，故这里不再赘述。")]),t._v(" "),e("p",[t._v("其它的写入非字节的方法，本质和写入"),e("strong",[t._v("int")]),t._v("一致，故也不再赘述。")]),t._v(" "),e("h1",{attrs:{id:"_6-bytebuffer的读操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-bytebuffer的读操作"}},[t._v("#")]),t._v(" 6. ByteBuffer的读操作")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("中定义了大量读操作相关的抽象方法，如下图所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/c40682f330e14d3a8d50b95f803e50ba~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=gdMdMnCzGPuleI2L3HDTpEjGNUY%3D",alt:""}})]),t._v(" "),e("p",[t._v("总体可以进行如下归类。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/15f65a9d87714f02ab1a09e0d79ff424~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=cR5O0ysZJmoXksoLe3fY4sA4gj8%3D",alt:""}})]),t._v(" "),e("p",[t._v("下面将对上述部分读方法结合源码进行说明。")]),t._v(" "),e("h1",{attrs:{id:"i-get"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#i-get"}},[t._v("#")]),t._v(" Ⅰ. get()")]),t._v(" "),e("p",[e("strong",[t._v("get()")]),t._v(" 方法用于读取一个字节，"),e("strong",[t._v("HeapByteBuffer")]),t._v("的实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public byte get() {\n    return hb[ix(nextGetIndex())];\n}\n复制代码\n")])])]),e("p",[t._v("上述方法是读取字节数组中"),e("strong",[t._v("position")]),t._v("索引位置的字节，然后"),e("strong",[t._v("position")]),t._v("加1。再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("get()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public byte get() {\n    return ((unsafe.getByte(ix(nextGetIndex()))));\n}\n复制代码\n")])])]),e("p",[t._v("上述方法是基于"),e("strong",[t._v("native")]),t._v("方法拿到"),e("strong",[t._v("address + position")]),t._v("位置的字节然后"),e("strong",[t._v("position")]),t._v("加1。")]),t._v(" "),e("h1",{attrs:{id:"ii-get-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ii-get-int"}},[t._v("#")]),t._v(" Ⅱ. get(int)")]),t._v(" "),e("p",[e("strong",[t._v("get(int)")]),t._v(" 方法用于读取指定位置的字节，"),e("strong",[t._v("HeapByteBuffer")]),t._v("的实现如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public byte get(int i) {\n    return hb[ix(checkIndex(i))];\n}\n复制代码\n")])])]),e("p",[t._v("上述方法会读取字节数组中指定索引位置的字节，注意"),e("strong",[t._v("position")]),t._v("不会改变。再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("get(int)")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public byte get(int i) {\n    return ((unsafe.getByte(ix(checkIndex(i)))));\n}\n复制代码\n")])])]),e("p",[t._v("上述方法是基于"),e("strong",[t._v("native")]),t._v("方法拿到指定位置的字节，同样，"),e("strong",[t._v("position")]),t._v("不会改变。")]),t._v(" "),e("h1",{attrs:{id:"iii-get-byte-int-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iii-get-byte-int-int"}},[t._v("#")]),t._v(" Ⅲ. get(byte[], int, int)")]),t._v(" "),e("p",[e("strong",[t._v("get(byte[], int, int)")]),t._v(" 方法用于将当前"),e("strong",[t._v("ByteBuffer")]),t._v("从"),e("strong",[t._v("position")]),t._v("位置开始往后的若干字节写入到目标字节数组的指定位置。"),e("strong",[t._v("ByteBuffer")]),t._v("，"),e("strong",[t._v("HeapByteBuffer")]),t._v("和"),e("strong",[t._v("DirectByteBuffer")]),t._v("都有相应的实现，下面分别看一下。")]),t._v(" "),e("p",[e("strong",[t._v("ByteBuffer")]),t._v("对"),e("strong",[t._v("get(byte[], int, int)")]),t._v(" 方法的实现中是一个字节一个字节的读取并写入，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer get(byte[] dst, int offset, int length) {\n    checkBounds(offset, length, dst.length);\n    if (length > remaining()) {\n        throw new BufferUnderflowException();\n    }\n    int end = offset + length;\n    // 写入目标数组的开始位置是offset\n    // 共写入length个字节\n    for (int i = offset; i < end; i++) {\n        dst[i] = get();\n    }\n    return this;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("HeapByteBuffer")]),t._v("对"),e("strong",[t._v("get(byte[], int, int)")]),t._v(" 方法的实现中，是调用"),e("strong",[t._v("System#arraycopy")]),t._v("本地方法来进行批量拷贝写入，效率比一个字节一个字节的读取并写入更高，且最后会更新当前"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer get(byte[] dst, int offset, int length) {\n    checkBounds(offset, length, dst.length);\n    if (length > remaining()) {\n        throw new BufferUnderflowException();\n    }\n    // 调用native方法来批量写入字节到dst字节数组\n    System.arraycopy(hb, ix(position()), dst, offset, length);\n    // 更新当前HeapByteBuffer的position\n    position(position() + length);\n    return this;\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("get(byte[], int, int)")]),t._v(" 方法的实现中，会先判断需要读取并写入到目标字节数组中的字节数是否大于6，大于6时会调用"),e("strong",[t._v("native")]),t._v("方法来批量写入，否则就一个字节一个字节的读取并写入，最终还会更新当前"),e("strong",[t._v("DirectByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer get(byte[] dst, int offset, int length) {\n    if (((long) length << 0) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n        // 批量写入的字节数大于6个\n        checkBounds(offset, length, dst.length);\n        int pos = position();\n        int lim = limit();\n        assert (pos <= lim);\n        int rem = (pos <= lim ? lim - pos : 0);\n        if (length > rem) {\n            throw new BufferUnderflowException();\n        }\n        // 最终调用到Unsafe#copyMemory方法完成批量拷贝写入\n        Bits.copyToArray(ix(pos), dst, arrayBaseOffset,\n                (long) offset << 0,\n                (long) length << 0);\n        // 更新当前DirectByteBuffer的position\n        position(pos + length);\n    } else {\n        // 批量写入的字节数小于等于6个\n        // 则一个字节一个字节的读取并写入\n        super.get(dst, offset, length);\n    }\n    return this;\n}\n复制代码\n")])])]),e("h1",{attrs:{id:"iv-get-byte"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iv-get-byte"}},[t._v("#")]),t._v(" Ⅳ. get(byte[])")]),t._v(" "),e("p",[e("strong",[t._v("get(byte[])")]),t._v(" 方法会从当前"),e("strong",[t._v("ByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("位置开始，读取目标字节数组长度个字节，然后依次写入到目标字节数组。"),e("strong",[t._v("get(byte[])")]),t._v(" 方法由"),e("strong",[t._v("ByteBuffer")]),t._v("实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public ByteBuffer get(byte[] dst) {\n    return get(dst, 0, dst.length);\n}\n复制代码\n")])])]),e("p",[t._v("那么本质还是依赖"),e("strong",[t._v("get(byte[], int, int)")]),t._v(" 方法，只不过将"),e("strong",[t._v("offset")]),t._v("指定为了0（表示从"),e("strong",[t._v("dst")]),t._v("字节数组的索引为0的位置开始写入），将"),e("strong",[t._v("length")]),t._v("指定为了"),e("strong",[t._v("dst.length")]),t._v("（表示要写满"),e("strong",[t._v("dst")]),t._v("字节数组）。")]),t._v(" "),e("h1",{attrs:{id:"v-getint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-getint"}},[t._v("#")]),t._v(" Ⅴ. getInt()")]),t._v(" "),e("p",[e("strong",[t._v("getInt()")]),t._v(" 方法表示从"),e("strong",[t._v("ByteBuffer")]),t._v("中读取一个"),e("strong",[t._v("int")]),t._v("值，先看一下"),e("strong",[t._v("HeapByteBuffer")]),t._v("的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public int getInt() {\n    // 通过nextGetIndex(4)拿到当前position，然后position加4\n    // 默认bigEndian为true，表示以大端字节序的方式读取int\n    return Bits.getInt(this, ix(nextGetIndex(4)), bigEndian);\n}\n\n// Bits#getInt\nstatic int getInt(ByteBuffer bb, int bi, boolean bigEndian) {\n    return bigEndian ? getIntB(bb, bi) : getIntL(bb, bi) ;\n}\n\n// Bits#getIntB\nstatic int getIntB(ByteBuffer bb, int bi) {\n    // 依次拿到低索引到高索引的字节\n    // 这些字节依次对应int值的高位到低位\n    // 最终调用makeInt()方法拼接成int值\n    return makeInt(bb._get(bi),\n            bb._get(bi + 1),\n            bb._get(bi + 2),\n            bb._get(bi + 3));\n}\n\n// Bits#makeInt\nstatic private int makeInt(byte b3, byte b2, byte b1, byte b0) {\n    return (((b3) << 24) |\n            ((b2 & 0xff) << 16) |\n            ((b1 & 0xff) << 8) |\n            ((b0 & 0xff)));\n}\n\n// HeapByteBuffer#_get\nbyte _get(int i) {\n    return hb[i];\n}\n复制代码\n")])])]),e("p",[t._v("上述方法的实现中，首先获取到当前"),e("strong",[t._v("HeapByteBuffer")]),t._v("的"),e("strong",[t._v("position")]),t._v("，然后从"),e("strong",[t._v("position")]),t._v("位置开始依次读取四个字节，因为默认情况下是大端字节序（也就是写和读都是按照大端字节序的方式），所以读取到的字节应该依次对应"),e("strong",[t._v("int")]),t._v("值的高位到低位，所以最终会在"),e("strong",[t._v("Bits#makeInt")]),t._v("方法中将四个字节通过错位或的方式得到"),e("strong",[t._v("int")]),t._v("值。")]),t._v(" "),e("p",[t._v("再看一下"),e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("getInt()")]),t._v(" 方法的实现，如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public int getInt() {\n    // 通过nextGetIndex(4)拿到当前position，然后position加4\n    // 通过ix()方法拿到操作的起始地址是address + position\n    return getInt(ix(nextGetIndex((1 << 2))));\n}\n\n// DirectByteBuffer#getInt(long)\nprivate int getInt(long a) {\n    if (unaligned) {\n        int x = unsafe.getInt(a);\n        return (nativeByteOrder ? x : Bits.swap(x));\n    }\n    // 默认bigEndian为true，表示默认大端字节序\n    return Bits.getInt(a, bigEndian);\n}\n\n// Bits#getInt\nstatic int getInt(long a, boolean bigEndian) {\n    return bigEndian ? getIntB(a) : getIntL(a) ;\n}\n\n// Bits#getIntB\nstatic int getIntB(long a) {\n    // 从低地址拿到int值的高位\n    // 从高地址拿到int值的低位\n    // 然后拼接得到最终的int值\n    return makeInt(_get(a),\n            _get(a + 1),\n            _get(a + 2),\n            _get(a + 3));\n}\n\n// Bits#_get\nprivate static byte _get(long a) {\n    return unsafe.getByte(a);\n}\n\n// Bits#makeInt\nstatic private int makeInt(byte b3, byte b2, byte b1, byte b0) {\n    return (((b3) << 24) |\n            ((b2 & 0xff) << 16) |\n            ((b1 & 0xff) << 8) |\n            ((b0 & 0xff)));\n}\n复制代码\n")])])]),e("p",[e("strong",[t._v("DirectByteBuffer")]),t._v("对"),e("strong",[t._v("getInt()")]),t._v(" 方法的整体实现思路和"),e("strong",[t._v("HeapByteBuffer")]),t._v("是一致的，在默认大端字节序的情况下，从低地址拿到"),e("strong",[t._v("int")]),t._v("值的高位字节，从高地址拿到"),e("strong",[t._v("int")]),t._v("值的低位字节，最后通过错位或的方式得到最终的"),e("strong",[t._v("int")]),t._v("值。请注意，操作完成后，"),e("strong",[t._v("position")]),t._v("都会加4，这是因为一个"),e("strong",[t._v("int")]),t._v("占四个字节，也就是相当于读取了4个字节。")]),t._v(" "),e("h1",{attrs:{id:"vi-getint-int"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vi-getint-int"}},[t._v("#")]),t._v(" Ⅵ. getInt(int)")]),t._v(" "),e("p",[e("strong",[t._v("getInt(int)")]),t._v(" 方法能够从指定位置读取一个"),e("strong",[t._v("int")]),t._v("值，实现思路和"),e("strong",[t._v("getInt()")]),t._v(" 方法完全一致，故这里不再赘述，但需要注意的是，"),e("strong",[t._v("getInt(int)")]),t._v(" 方法读取一个"),e("strong",[t._v("int")]),t._v("值后，不会改变"),e("strong",[t._v("position")]),t._v("。")]),t._v(" "),e("p",[t._v("其它的非字节的读取，本质和"),e("strong",[t._v("int")]),t._v("值的读取一样，故也不再赘述。")]),t._v(" "),e("h1",{attrs:{id:"_7-bytebuffer的使用示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-bytebuffer的使用示例"}},[t._v("#")]),t._v(" 7. ByteBuffer的使用示例")]),t._v(" "),e("p",[t._v("在"),e("strong",[t._v("Log4j2")]),t._v("日志框架中，最终在将日志进行输出时，对日志内容的处理就有使用到"),e("strong",[t._v("ByteBuffer")]),t._v("，下面一起来简单的看一下。（无需关注"),e("strong",[t._v("Log4j2")]),t._v("的实现细节）")]),t._v(" "),e("p",[t._v("在将日志内容进行标准输出时，最终是通过"),e("strong",[t._v("OutputStreamManager")]),t._v("完成将日志内容输出，它里面有一个字段就是"),e("strong",[t._v("HeapByteBuffer")]),t._v("，用于存储日志内容的字节数据。下面先看一下**\norg.apache.logging.log4j.core.layout.TextEncoderHelper#writeEncodedText"),e("strong",[t._v("方法，这里面会有")]),t._v("OutputStreamManager"),e("strong",[t._v("的")]),t._v("ByteBuffer**如何被写入的相关逻辑。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private static void writeEncodedText(final CharsetEncoder charsetEncoder, final CharBuffer charBuf,\n        final ByteBuffer byteBuf, final ByteBufferDestination destination, CoderResult result) {\n  \n    ......\n  \n    if (byteBuf != destination.getByteBuffer()) {\n        // 这里的byteBuf存储了处理后的日志内容\n        // 调用flip()方法来进入读模式\n        byteBuf.flip();\n        // 这里的destination就是OutputStreamManager\n        // 这里会将byteBuf的内容写到OutputStreamManager的ByteBuffer中\n        destination.writeBytes(byteBuf);\n        // 切换为写模式，也就是position置0，重置limit等于capacity等\n        byteBuf.clear();\n    }\n}\n\n// OutputStreamManager#writeBytes\npublic void writeBytes(final ByteBuffer data) {\n    if (data.remaining() == 0) {\n        return;\n    }\n    synchronized (this) {\n        ByteBufferDestinationHelper.writeToUnsynchronized(data, this);\n    }\n}\n\n// ByteBufferDestinationHelper#writeToUnsynchronized\npublic static void writeToUnsynchronized(final ByteBuffer source, final ByteBufferDestination destination) {\n    // 拿到OutputStreamManager中的HeapByteBuffer\n    // 这里称OutputStreamManager中的HeapByteBuffer为目标ByteBuffer\n    ByteBuffer destBuff = destination.getByteBuffer();\n    // 如果源ByteBuffer剩余可读字节多于目标ByteBuffer剩余可写字节\n    // 则循环的写满目标ByteBuffer再读取完目标ByteBuffer\n    // 最终就是需要将源ByteBuffer的字节全部由目标ByteBuffer消费掉\n    while (source.remaining() > destBuff.remaining()) {\n        final int originalLimit = source.limit();\n        // 先将源ByteBuffer的limit设置为当前position + 目标ByetBuffer剩余可写字节数\n        source.limit(Math.min(source.limit(), source.position() + destBuff.remaining()));\n        // 将源ByteBuffer当前position到limit的字节写到目标ByteBuffer中\n        destBuff.put(source);\n        // 恢复源ByteBuffer的limit\n        source.limit(originalLimit);\n        // 目标ByteBuffer先将已有的字节全部标准输出\n        // 然后返回一个写模式的目标ByteBuffer\n        destBuff = destination.drain(destBuff);\n    }\n  \n    // 到这里说明源ByteBuffer剩余可读字节小于等于目标ByteBuffer剩余可写字节\n    // 则将源ByteBuffer剩余可读字节全部写到目标ByteBuffer中\n    // 后续会在其它地方将这部分内容全部标准输出\n    destBuff.put(source);\n}\n\n// OutputStreamManager#drain\npublic ByteBuffer drain(final ByteBuffer buf) {\n    flushBuffer(buf);\n    return buf;\n}\n\n// OutputStreamManager#flushBuffer\nprotected synchronized void flushBuffer(final ByteBuffer buf) {\n    // 目标ByteBuffer切换为读模式\n    ((Buffer) buf).flip();\n    try {\n        if (buf.remaining() > 0) {\n            // 拿到HeapByteBuffer中的字节数组\n            // 最终调用到PrintStream来标准输出字节数组中的字节内容\n            writeToDestination(buf.array(), buf.arrayOffset() + buf.position(), buf.remaining());\n        }\n    } finally {\n        // 目标ByteBuffer切换回写模式\n        buf.clear();\n    }\n}\n复制代码\n")])])]),e("p",[t._v("相信如果阅读完本文，那么上述"),e("strong",[t._v("Log4j2")]),t._v("中对于"),e("strong",[t._v("ByteBuffer")]),t._v("的使用，肯定都是能看明白的，虽然"),e("strong",[t._v("Log4j2")]),t._v("中有大量的基于"),e("strong",[t._v("ByteBuffer")]),t._v("的使用，但是最终的标准输出还是基于"),e("strong",[t._v("Java")]),t._v("的传统"),e("strong",[t._v("IO")]),t._v("来输出的，那么为什么中间还要用"),e("strong",[t._v("ByteBuffer")]),t._v("来多处理一下呢，其实也就是因为"),e("strong",[t._v("ByteBuffer")]),t._v("在读写字节时会考虑性能问题，会使用到性能更高的"),e("strong",[t._v("native")]),t._v("方法来批量的操作字节数据，因此以快著称的"),e("strong",[t._v("Log4j2")]),t._v("选择了"),e("strong",[t._v("NIO")]),t._v("中的"),e("strong",[t._v("ByteBuffer")]),t._v("。")]),t._v(" "),e("h1",{attrs:{id:"_8-bytebuffer的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-bytebuffer的缺点"}},[t._v("#")]),t._v(" 8. ByteBuffer的缺点")]),t._v(" "),e("p",[t._v("如果要讨论"),e("strong",[t._v("ByteBuffer")]),t._v("的缺点，其实可以结合第7小节的使用示例来一并讨论。")]),t._v(" "),e("p",[t._v("首先就是"),e("strong",[t._v("读写模式的切换")]),t._v("。在第7小节示例中，会发现存在多处调用"),e("strong",[t._v("flip()")]),t._v(" 方法来切换到读模式，调用"),e("strong",[t._v("clear()")]),t._v(" 方法来切换到写模式，这种模式的切换，既麻烦，还容易出错。")]),t._v(" "),e("p",[t._v("然后就是"),e("strong",[t._v("无法扩容")]),t._v("。在第7小节示例中，有一个细节就是因为"),e("strong",[t._v("ByteBuffer")]),t._v("容量太小了，无法一次写完所有字节数据，所以就只能循环的写满读取然后再写满这样子来操作，如果能扩容就不用这么麻烦了。")]),t._v(" "),e("p",[t._v("最后就是"),e("strong",[t._v("线程不安全")]),t._v("。"),e("strong",[t._v("ByteBuffer")]),t._v("自身并没有提供对线程安全的保护，要实现线程安全，需要使用者自己通过其它的并发语义来实现。")]),t._v(" "),e("h1",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("本文对"),e("strong",[t._v("ByteBuffer")]),t._v("的分析可以参照下图。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p26-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7c7b0ea9e6ce4355b14154d82d9e7173~noop.image?_iz=58558&from=article.pc_detail&x-expires=1687572286&x-signature=BDJTCcf2vl%2Fj%2BgxlHvHbVCrRr4w%3D",alt:""}})]),t._v(" "),e("p",[t._v("为啥"),e("strong",[t._v("NIO")]),t._v("中偏分析"),e("strong",[t._v("ByteBuffer")]),t._v("呢，因为"),e("strong",[t._v("Netty")]),t._v("中的缓存是"),e("strong",[t._v("ByteBuf")]),t._v("，其对"),e("strong",[t._v("ByteBuffer")]),t._v("做了改良.")]),t._v(" "),e("p",[t._v("文章来源：https://www.toutiao.com/article/7217621755463631372/?log_from=4216f0af143da_1686967401390")]),t._v(" "),e("backTop")],1)}),[],!1,null,null,null);n.default=i.exports}}]);