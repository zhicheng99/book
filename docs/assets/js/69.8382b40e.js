(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{405:function(v,e,_){"use strict";_.r(e);var a=_(10),t=Object(a.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"canvas性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#canvas性能优化"}},[v._v("#")]),v._v(" Canvas性能优化")]),v._v(" "),_("p",[v._v("最近对 "),_("code",[v._v("html5")]),v._v("小游戏有点兴趣，因为我感觉将来这个东西或许是前端一个重要的应用场景，例如现在每到某些节假日，像支付宝、淘宝或者其他的一些 "),_("code",[v._v("APP")]),v._v("可能会给你推送通知，然后点进去就是一个小游戏，基本上点进去的人，只要不是太抵触，都会玩上一玩的，如果要是恰好 "),_("code",[v._v("get")]),v._v("到用户的 "),_("code",[v._v("G")]),v._v("点，还能进一步增强业务，无论是用户体验，还是对业务的发展，都是一种很不错的提升方式。")]),v._v(" "),_("p",[v._v("另外，我说的这个 "),_("code",[v._v("html5")]),v._v("小游戏是包括 "),_("code",[v._v("WebGL")]),v._v("、"),_("code",[v._v("WebVR")]),v._v("等在内的东西，不仅限于游戏，也可以是其他用到相关技术的场景，例如商品图片 "),_("code",[v._v("360°")]),v._v("在线查看这种，之所以从小游戏入手，是因为小游戏需要的技术包罗万象，能把游戏做好，再用相同的技术去做其他的事情，就比较信手拈来了")]),v._v(" "),_("p",[v._v("查找资料，发现门道还是蛮多的，看了一圈下来，决定从基础入手，先从较为简单的 "),_("code",[v._v("canvas")]),v._v(" 游戏看起，看了一些相关文章和书籍，发现这个东西虽然用起来很简单，但是真想用好，发挥其该有的能力还是有点难度的，最好从实战入手")]),v._v(" "),_("p",[v._v("于是最近准备写个 "),_("code",[v._v("canvas")]),v._v("小游戏练手，相关 "),_("code",[v._v("UI")]),v._v("素材已经搜集好了，不过俗话说 "),_("strong",[v._v("工欲善其事必先利其器")]),v._v("，由于对这方面没什么经验，所以为了避免过程中出现的各种坑点，特地又看了一些相关的踩坑文章，其中性能我感觉是必须要注意的地方，而且门道很多，所以整理了一下")]),v._v(" "),_("h2",{attrs:{id:"使用-requestnextanimationframe进行动画循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-requestnextanimationframe进行动画循环"}},[v._v("#")]),v._v(" 使用 "),_("code",[v._v("requestNextAnimationFrame")]),v._v("进行动画循环")]),v._v(" "),_("p",[_("code",[v._v("setTimeout")]),v._v(" 和 "),_("code",[v._v("setInterval")]),v._v("并非是专为连续循环产生的 "),_("code",[v._v("API")]),v._v("，所以可能无法达到流畅的动画表现，故用 "),_("code",[v._v("requestNextAnimationFrame")]),v._v("，可能需要 "),_("code",[v._v("polyfill")]),v._v("：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const raf = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || window.oRequestAnimationFrame\n  || window.msRequestAnimationFrame\n  || function(callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n复制代码\n")])])]),_("h2",{attrs:{id:"利用剪辑区域来处理动画背景或其他不变的图像"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#利用剪辑区域来处理动画背景或其他不变的图像"}},[v._v("#")]),v._v(" 利用剪辑区域来处理动画背景或其他不变的图像")]),v._v(" "),_("p",[v._v("如果只是简单动画，那么每一帧动画擦除并重绘画布上所有内容是可取的操作，但如果背景比较复杂，那么可以使用 "),_("strong",[v._v("剪辑区域")]),v._v("技术，通过每帧较少的绘制来获得更好的性能")]),v._v(" "),_("p",[v._v("利用剪辑区域技术来恢复上一帧动画所占背景图的执行步骤：")]),v._v(" "),_("ul",[_("li",[v._v("调用"),_("code",[v._v("context.save()")]),v._v("，保存屏幕"),_("code",[v._v("canvas")]),v._v("的状态")]),v._v(" "),_("li",[v._v("通过调用"),_("code",[v._v("beginPath")]),v._v("来开始一段新的路径")]),v._v(" "),_("li",[v._v("在"),_("code",[v._v("context")]),v._v("对象上调用"),_("code",[v._v("arc()")]),v._v("、"),_("code",[v._v("rect()")]),v._v("等方法来设置路径")]),v._v(" "),_("li",[v._v("调用"),_("code",[v._v("context.clip()")]),v._v("方法，将当前路径设置为屏幕"),_("code",[v._v("canvas")]),v._v("的剪辑区域")]),v._v(" "),_("li",[v._v("擦除屏幕"),_("code",[v._v("canvas")]),v._v("中的图像（实际上只会擦除剪辑区域所在的这一块范围）")]),v._v(" "),_("li",[v._v("将背景图像绘制到屏幕"),_("code",[v._v("canvas")]),v._v("上（绘制操作实际上只会影响剪辑区域所在的范围，所以每帧绘制图像像素数更少）")]),v._v(" "),_("li",[v._v("恢复屏幕"),_("code",[v._v("canvas")]),v._v("的状态参数，重置剪辑区域")])]),v._v(" "),_("h2",{attrs:{id:"离屏缓冲区-离屏canvas"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#离屏缓冲区-离屏canvas"}},[v._v("#")]),v._v(" 离屏缓冲区(离屏canvas)")]),v._v(" "),_("p",[v._v("先绘制到一个离屏 "),_("code",[v._v("canvas")]),v._v("中，然后再通过 "),_("code",[v._v("drawImage")]),v._v("把离屏 "),_("code",[v._v("canvas")]),v._v(" 画到主 "),_("code",[v._v("canvas")]),v._v("中，就是把离屏 "),_("code",[v._v("canvas")]),v._v("当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 "),_("code",[v._v("canvas")]),v._v("的 "),_("code",[v._v("API")]),v._v("的消耗")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const cacheCanvas = document.createElement('canvas')\nconst cacheCtx = cacheCanvas.getContext('2d')\ncacheCtx.width = 200\ncacheCtx.height = 200\n// 绘制到主canvas上\nctx.drawImage(0, 0)\n复制代码\n")])])]),_("p",[v._v("虽然离屏 "),_("code",[v._v("canvas")]),v._v("在绘制之前视野内看不到，但其宽高最好设置得跟缓存元素的尺寸一样，避免资源浪费，也避免绘制多余的不必要图像，同时在 "),_("code",[v._v("drawImage")]),v._v("时缩放图像也将耗费资源\n必要时，可以使用多个离屏 "),_("code",[v._v("canvas")]),v._v("\n另外，离屏 "),_("code",[v._v("canvas")]),v._v("不再使用时，最好把手动将引用重置为 "),_("code",[v._v("null")]),v._v("，避免因为 "),_("code",[v._v("js")]),v._v("和 "),_("code",[v._v("dom")]),v._v("之间存在的关联，导致垃圾回收机制无法正常工作，占用资源")]),v._v(" "),_("h2",{attrs:{id:"尽量利用-css"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量利用-css"}},[v._v("#")]),v._v(" 尽量利用 "),_("code",[v._v("CSS")])]),v._v(" "),_("h3",{attrs:{id:"背景图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#背景图"}},[v._v("#")]),v._v(" 背景图")]),v._v(" "),_("p",[v._v("如果有大的静态背景图，直接绘制到 "),_("code",[v._v("canvas")]),v._v("可能并不是一个很好的做法，如果可以，将这个大背景图作为 "),_("code",[v._v("background-image")]),v._v(" 放在一个 "),_("code",[v._v("DOM")]),v._v("元素上(例如，一个  "),_("code",[v._v("div")]),v._v(")，然后将这个元素放到 "),_("code",[v._v("canvas")]),v._v("后面，这样就少了一个  "),_("code",[v._v("canvas")]),v._v("的绘制渲染")]),v._v(" "),_("h3",{attrs:{id:"transform变幻"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#transform变幻"}},[v._v("#")]),v._v(" transform变幻")]),v._v(" "),_("p",[_("code",[v._v("CSS")]),v._v("的 "),_("code",[v._v("transform")]),v._v("性能优于 "),_("code",[v._v("canvas")]),v._v("的 "),_("code",[v._v("transfomr API")]),v._v("，因为前者基于可以很好地利用 "),_("code",[v._v("GPU")]),v._v("，所以如果可以，"),_("code",[v._v("transform")]),v._v("变幻请使用 "),_("code",[v._v("CSS")]),v._v("来控制")]),v._v(" "),_("h2",{attrs:{id:"关闭透明度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关闭透明度"}},[v._v("#")]),v._v(" 关闭透明度")]),v._v(" "),_("p",[v._v("创建 "),_("code",[v._v("canvas")]),v._v("上下文的 "),_("code",[v._v("API")]),v._v("存在第二个参数：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("canvas.getContext(contextType, contextAttributes)\n复制代码\n")])])]),_("p",[_("code",[v._v("contextType")]),v._v(" 是上下文类型，一般值都是 "),_("code",[v._v("2d")]),v._v("，除此之外还有 "),_("code",[v._v("webgl")]),v._v("、"),_("code",[v._v("webgl2")]),v._v("、"),_("code",[v._v("bitmaprenderer")]),v._v("三个值，只不过后面三个浏览器支持度太低，一般不用")]),v._v(" "),_("p",[_("code",[v._v("contextAttributes")]),v._v(" 是上下文属性，用于初始化上下文的一些属性，对于不同的 "),_("code",[v._v("contextType")]),v._v("，"),_("code",[v._v("contextAttributes")]),v._v("的可取值也不同，对于常用的 "),_("code",[v._v("2d")]),v._v("，"),_("code",[v._v("contextAttributes")]),v._v("可取值有：")]),v._v(" "),_("ul",[_("li",[v._v("alpha")])]),v._v(" "),_("p",[_("code",[v._v("boolean")]),v._v("类型值，表明 "),_("code",[v._v("canvas")]),v._v("包含一个 "),_("code",[v._v("alpha")]),v._v("通道. 默认为 "),_("code",[v._v("true")]),v._v("，如果设置为 "),_("code",[v._v("false")]),v._v(", 浏览器将认为 "),_("code",[v._v("canvas")]),v._v("背景总是不透明的, 这样可以加速绘制透明的内容和图片")]),v._v(" "),_("ul",[_("li",[v._v("willReadFrequently")])]),v._v(" "),_("p",[_("code",[v._v("boolean")]),v._v("类型值，表明是否有重复读取计划。经常使用 "),_("code",[v._v("getImageData()")]),v._v("，这将迫使软件使用 "),_("code",[v._v("2D canvas")]),v._v(" 并节省内存（而不是硬件加速）。这个方案适用于存在属性 "),_("code",[v._v("gfx.canvas.willReadFrequently")]),v._v("的环境。并设置为 "),_("code",[v._v("true")]),v._v(" (缺省情况下,只有 "),_("code",[v._v("B2G / Firefox OS")]),v._v(")")]),v._v(" "),_("p",[v._v("支持度低，目前只有 "),_("code",[v._v("Gecko")]),v._v("内核的浏览器支持，不常用")]),v._v(" "),_("ul",[_("li",[v._v("storage")])]),v._v(" "),_("p",[_("code",[v._v("string")]),v._v(" 这样表示使用哪种方式存储(默认为：持久（"),_("code",[v._v("persistent")]),v._v("）)")]),v._v(" "),_("p",[v._v("支持度低，目前只有 "),_("code",[v._v("Blink")]),v._v("内核的浏览器支持，不常用")]),v._v(" "),_("p",[v._v("上面三个属性，看常用的 "),_("code",[v._v("alpha")]),v._v("就行了，如果你的游戏使用画布而且不需要透明，当使用 "),_("code",[v._v("HTMLCanvasElement.getContext()")]),v._v(" 创建一个绘图上下文时把 "),_("code",[v._v("alpha")]),v._v(" 选项设置为 "),_("code",[v._v("false")]),v._v(" ，这个选项可以帮助浏览器进行内部优化")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const ctx = canvas.getContext('2d', { alpha: false })\n复制代码\n")])])]),_("h2",{attrs:{id:"尽量不要频繁地调用比较耗时的api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量不要频繁地调用比较耗时的api"}},[v._v("#")]),v._v(" 尽量不要频繁地调用比较耗时的API")]),v._v(" "),_("p",[v._v("例如")]),v._v(" "),_("p",[_("code",[v._v("shadow")]),v._v("相关 "),_("code",[v._v("API")]),v._v("，此类 "),_("code",[v._v("API")]),v._v("包括 "),_("code",[v._v("shadowOffsetX")]),v._v("、"),_("code",[v._v("shadowOffsetY")]),v._v("、"),_("code",[v._v("shadowBlur")]),v._v("、"),_("code",[v._v("shadowColor")])]),v._v(" "),_("p",[v._v("绘图相关的 "),_("code",[v._v("API")]),v._v("，例如 "),_("code",[v._v("drawImage")]),v._v("、"),_("code",[v._v("putImageData")]),v._v("，在绘制时进行缩放操作也会增加耗时时间")]),v._v(" "),_("p",[v._v("当然，上述都是尽量避免 "),_("strong",[v._v("频繁")]),v._v("调用，或用其他手段来控制性能，需要用到的地方肯定还是要用的")]),v._v(" "),_("h2",{attrs:{id:"避免浮点数的坐标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免浮点数的坐标"}},[v._v("#")]),v._v(" 避免浮点数的坐标")]),v._v(" "),_("p",[v._v("利用 "),_("code",[v._v("canvas")]),v._v("进行动画绘制时，如果计算出来的坐标是浮点数，那么可能会出现 "),_("code",[v._v("CSS Sub-pixel")]),v._v("的问题，也就是会自动将浮点数值四舍五入转为整数，那么在动画的过程中，由于元素实际运动的轨迹并不是严格按照计算公式得到，那么就可能出现抖动的情况，同时也可能让元素的边缘出现抗锯齿失真\n这也是可能影响性能的一方面，因为一直在做不必要的取证运算")]),v._v(" "),_("h2",{attrs:{id:"渲染绘制操作不要频繁调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染绘制操作不要频繁调用"}},[v._v("#")]),v._v(" 渲染绘制操作不要频繁调用")]),v._v(" "),_("p",[v._v("渲染绘制的 "),_("code",[v._v("api")]),v._v("，例如 "),_("code",[v._v("stroke()")]),v._v("、"),_("code",[v._v("fill")]),v._v("、"),_("code",[v._v("drawImage")]),v._v("，都是将 "),_("code",[v._v("ctx")]),v._v("状态机里面的状态真实绘制到画布上，这种操作也比较耗费性能")]),v._v(" "),_("p",[v._v("例如，如果你要绘制十条线段，那么先在 "),_("code",[v._v("ctx")]),v._v("状态机中绘制出十天线段的状态机，再进行一次性的绘制，这将比每条线段都绘制一次要高效得多")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("for (let i = 0; i < 10; i++) {\n  context.beginPath()\n  context.moveTo(x1[i], y1[i])\n  context.lineTo(x2[i], y2[i])\n  // 每条线段都单独调用绘制操作，比较耗费性能\n  context.stroke()\n}\n\nfor (let i = 0; i < 10; i++) {\n  context.beginPath()\n  context.moveTo(x1[i], y1[i])\n  context.lineTo(x2[i], y2[i])\n}\n// 先绘制一条包含多条线条的路径，最后再一次性绘制，可以得到更好的性能\ncontext.stroke()\n复制代码\n")])])]),_("h2",{attrs:{id:"尽量少的改变状态机-ctx的里状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量少的改变状态机-ctx的里状态"}},[v._v("#")]),v._v(" 尽量少的改变状态机 ctx的里状态")]),v._v(" "),_("p",[_("code",[v._v("ctx")]),v._v("可以看做是一个状态机，例如 "),_("code",[v._v("fillStyle")]),v._v("、"),_("code",[v._v("globalAlpha")]),v._v("、"),_("code",[v._v("beginPath")]),v._v("，这些 "),_("code",[v._v("api")]),v._v("都会改变 "),_("code",[v._v("ctx")]),v._v("里面对于的状态，频繁改变状态机的状态，是影响性能的")]),v._v(" "),_("p",[v._v("可以通过对操作进行更好的规划，减少状态机的改变，从而得到更加的性能，例如在一个画布上绘制几行文字，最上面和最下面文字的字体都是 "),_("code",[v._v("30px")]),v._v("，颜色都是 "),_("code",[v._v("yellowgreen")]),v._v("，中间文字是 "),_("code",[v._v("20px pink")]),v._v("，那么可以先绘制最上面和最下面的文字，再绘制中间的文字，而非必须从上往下依次绘制，因为前者减少了一次状态机的状态改变")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const c = document.getElementById(\"myCanvas\")\nconst ctx = c.getContext(\"2d\")\n\nctx.font = '30 sans-serif'\nctx.fillStyle = 'yellowgreen'\nctx.fillText(\"大家好，我是最上面一行\", 0, 40)\n\nctx.font = '20 sans-serif'\nctx.fillStyle = 'red'\nctx.fillText(\"大家好，我是中间一行\", 0, 80)\n\nctx.font = '30 sans-serif'\nctx.fillStyle = 'yellowgreen'\nctx.fillText(\"大家好，我是最下面一行\", 0, 130)\n复制代码\n")])])]),_("p",[v._v("下面的代码实现的效果和上面相同，但是代码量更少，同时比上述代码少改变了一次状态机，性能会更好")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("ctx.font = '30 sans-serif'\nctx.fillStyle = 'yellowgreen'\nctx.fillText(\"大家好，我是最上面一行\", 0, 40)\nctx.fillText(\"大家好，我是最下面一行\", 0, 130)\n\nctx.font = '20 sans-serif'\nctx.fillStyle = 'red'\nctx.fillText(\"大家好，我是中间一行\", 0, 80)\n复制代码\n")])])]),_("h2",{attrs:{id:"尽量少的调用-canvas-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量少的调用-canvas-api"}},[v._v("#")]),v._v(" 尽量少的调用 "),_("code",[v._v("canvas API")])]),v._v(" "),_("p",[v._v("嗯，"),_("code",[v._v("canvas")]),v._v("也是通过操纵 "),_("code",[v._v("js")]),v._v("来绘制的，但是相比于正常的 "),_("code",[v._v("js")]),v._v("操作，调用 "),_("code",[v._v("canvas API")]),v._v("将更加消耗资源，所以在绘制之前请做好规划，通过 "),_("strong",[v._v("适量")]),v._v(" "),_("code",[v._v("js")]),v._v("原生计算减少 "),_("code",[v._v("canvas API")]),v._v("的调用是一件比较划算的事情")]),v._v(" "),_("p",[v._v("当然，请注意 "),_("strong",[v._v("适量")]),v._v("二字，如果减少一行 "),_("code",[v._v("canvas API")]),v._v("调用的代价是增加十行 "),_("code",[v._v("js")]),v._v("计算，那这事可能就没必要做了")]),v._v(" "),_("h2",{attrs:{id:"避免阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免阻塞"}},[v._v("#")]),v._v(" 避免阻塞")]),v._v(" "),_("p",[v._v("在进行某些耗时操作，例如计算大量数据，一帧中包含了太多的绘制状态，大规模的 "),_("code",[v._v("DOM")]),v._v("操作等，可能会导致页面卡顿，影响用户体验，可以通过以下两种手段：")]),v._v(" "),_("h3",{attrs:{id:"web-worker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[v._v("#")]),v._v(" web worker")]),v._v(" "),_("p",[_("code",[v._v("web worker")]),v._v("最常用的场景就是大量的频繁计算，减轻主线程压力，如果遇到大规模的计算，可以通过此 "),_("code",[v._v("API")]),v._v("分担主线程压力，此 "),_("code",[v._v("API")]),v._v("兼容性已经很不错了，既然 "),_("code",[v._v("canvas")]),v._v("可以用，那 "),_("code",[v._v("web worker")]),v._v("也就完全可以考虑使用")]),v._v(" "),_("h3",{attrs:{id:"分解任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分解任务"}},[v._v("#")]),v._v(" 分解任务")]),v._v(" "),_("p",[v._v("将一段大的任务过程分解成数个小型任务，使用定时器轮询进行，想要对一段任务进行分解操作，此任务需要满足以下情况：")]),v._v(" "),_("ul",[_("li",[v._v("循环处理操作并不要求同步")]),v._v(" "),_("li",[v._v("数据并不要求按照顺序处理")])]),v._v(" "),_("p",[v._v("分解任务包括两种情形：")]),v._v(" "),_("ul",[_("li",[v._v("根据任务总量分配")])]),v._v(" "),_("p",[v._v("例如进行一个千万级别的运算总任务，可以将其分解为 "),_("code",[v._v("10")]),v._v("个百万级别的运算小任务")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("// 封装 定时器分解任务 函数\nfunction processArray(items, process, callback) {\n  // 复制一份数组副本\n  var todo=items.concat();\n  setTimeout(function(){\n    process(todo.shift());\n    if(todo.length>0) {\n      // 将当前正在执行的函数本身再次使用定时器\n      setTimeout(arguments.callee, 25);\n    } else {\n      callback(items);\n    }\n  }, 25);\n}\n\n// 使用\nvar items=[12,34,65,2,4,76,235,24,9,90];\nfunction outputValue(value) {\n  console.log(value);\n}\nprocessArray(items, outputValue, function(){\n  console.log('Done!');\n});\n复制代码\n")])])]),_("p",[v._v("优点是任务分配模式比较简单，更有控制权，缺点是不好确定小任务的大小")]),v._v(" "),_("p",[v._v("有的小任务可能因为某些原因，会耗费比其他小任务更多的时间，这会造成线程阻塞；而有的小任务可能需要比其他任务少得多的时间，造成资源浪费")]),v._v(" "),_("ul",[_("li",[v._v("根据运行时间分配")])]),v._v(" "),_("p",[v._v("例如运行一个千万级别的运算总任务，不直接确定分配为多少个子任务，或者分配的颗粒度比较小，在每一个或几个计算完成后，查看此段运算消耗的时间，如果时间小于某个临界值，比如 "),_("code",[v._v("10ms")]),v._v("，那么就继续进行运算，否则就暂停，等到下一个轮询再进行进行")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("function timedProcessArray(items, process, callback) {\n  var todo=items.concat();\n  setTimeout(function(){\n    // 开始计时\n    var start = +new Date();\n    // 如果单个数据处理时间小于 50ms ，则无需分解任务\n    do {\n      process(todo.shift());\n    } while (todo.length && (+new Date()-start < 50));\n\n    if(todo.length > 0) {\n      setTimeout(arguments.callee, 25);\n    } else {\n      callback(items);\n    }\n  });\n}\n复制代码\n")])])]),_("p",[v._v("优点是避免了第一种情况出现的问题，缺点是多出了一个时间比较的运算，额外的运算过程也可能影响到性能")]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("我准备做的 "),_("code",[v._v("canvas")]),v._v("游戏似乎需要的制作时间有点长，每天除了上班之外，剩下的时间实在是不多，不知道什么时候能搞完，如果一切顺利，我倒是还想再用一些游戏引擎，例如 "),_("code",[v._v("Egret")]),v._v("、"),_("code",[v._v("LayaAir")]),v._v("、"),_("code",[v._v("Cocos Creator")]),v._v(" 将其重制一遍，以熟悉这些游戏引擎的用法，然后到时候写个系列教程出来……")]),v._v(" "),_("p",[v._v("诶，这么看来，似乎是要持久战了啊")]),v._v(" "),_("p",[v._v("文章来源：https://juejin.cn/post/6844903682761310216")]),v._v(" "),_("backTop")],1)}),[],!1,null,null,null);e.default=t.exports}}]);