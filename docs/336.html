<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[核心概念] 一文说透JS中的原型和继承(上) | 日常收集</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/book/assets/css/0.styles.d473fa6d.css" as="style"><link rel="preload" href="/book/assets/js/app.a5076a9c.js" as="script"><link rel="preload" href="/book/assets/js/3.0d5fb1e8.js" as="script"><link rel="preload" href="/book/assets/js/127.fa6f9e4f.js" as="script"><link rel="preload" href="/book/assets/js/4.4c5f7830.js" as="script"><link rel="prefetch" href="/book/assets/js/10.c9f436af.js"><link rel="prefetch" href="/book/assets/js/100.c1fda999.js"><link rel="prefetch" href="/book/assets/js/101.26415c0a.js"><link rel="prefetch" href="/book/assets/js/102.04b9bf96.js"><link rel="prefetch" href="/book/assets/js/103.e1bb0d05.js"><link rel="prefetch" href="/book/assets/js/104.cc97244d.js"><link rel="prefetch" href="/book/assets/js/105.797b59ae.js"><link rel="prefetch" href="/book/assets/js/106.fac66328.js"><link rel="prefetch" href="/book/assets/js/107.a7c0255b.js"><link rel="prefetch" href="/book/assets/js/108.3aae0552.js"><link rel="prefetch" href="/book/assets/js/109.5dba325c.js"><link rel="prefetch" href="/book/assets/js/11.5e1abf35.js"><link rel="prefetch" href="/book/assets/js/110.a40e4289.js"><link rel="prefetch" href="/book/assets/js/111.79be6c5c.js"><link rel="prefetch" href="/book/assets/js/112.39a68b1f.js"><link rel="prefetch" href="/book/assets/js/113.d14d5801.js"><link rel="prefetch" href="/book/assets/js/114.9e3a5ae5.js"><link rel="prefetch" href="/book/assets/js/115.35834155.js"><link rel="prefetch" href="/book/assets/js/116.d728568b.js"><link rel="prefetch" href="/book/assets/js/117.57e7cda5.js"><link rel="prefetch" href="/book/assets/js/118.4cca96d1.js"><link rel="prefetch" href="/book/assets/js/119.e5e0d751.js"><link rel="prefetch" href="/book/assets/js/12.571f12ac.js"><link rel="prefetch" href="/book/assets/js/120.4bd8280b.js"><link rel="prefetch" href="/book/assets/js/121.96434c11.js"><link rel="prefetch" href="/book/assets/js/122.60e9d0a0.js"><link rel="prefetch" href="/book/assets/js/123.d8ddea9c.js"><link rel="prefetch" href="/book/assets/js/124.839d24ad.js"><link rel="prefetch" href="/book/assets/js/125.1e732e3b.js"><link rel="prefetch" href="/book/assets/js/126.5d06ad3c.js"><link rel="prefetch" href="/book/assets/js/128.731e9566.js"><link rel="prefetch" href="/book/assets/js/129.ade4c04a.js"><link rel="prefetch" href="/book/assets/js/13.94f0d951.js"><link rel="prefetch" href="/book/assets/js/130.e76b6393.js"><link rel="prefetch" href="/book/assets/js/131.cf345960.js"><link rel="prefetch" href="/book/assets/js/132.250f9d42.js"><link rel="prefetch" href="/book/assets/js/133.1a253cb2.js"><link rel="prefetch" href="/book/assets/js/134.fd4dd490.js"><link rel="prefetch" href="/book/assets/js/135.aad97280.js"><link rel="prefetch" href="/book/assets/js/136.17c9c79f.js"><link rel="prefetch" href="/book/assets/js/137.a64814a1.js"><link rel="prefetch" href="/book/assets/js/138.2f3a4047.js"><link rel="prefetch" href="/book/assets/js/139.99e6a29a.js"><link rel="prefetch" href="/book/assets/js/14.3d533f57.js"><link rel="prefetch" href="/book/assets/js/140.4d15508e.js"><link rel="prefetch" href="/book/assets/js/141.dc9a0fd9.js"><link rel="prefetch" href="/book/assets/js/142.68b18508.js"><link rel="prefetch" href="/book/assets/js/143.9a606518.js"><link rel="prefetch" href="/book/assets/js/144.f3ddc97d.js"><link rel="prefetch" href="/book/assets/js/145.03e0c0cb.js"><link rel="prefetch" href="/book/assets/js/146.011737f0.js"><link rel="prefetch" href="/book/assets/js/147.971b8acb.js"><link rel="prefetch" href="/book/assets/js/148.8bed0c77.js"><link rel="prefetch" href="/book/assets/js/149.da62226e.js"><link rel="prefetch" href="/book/assets/js/15.64e47055.js"><link rel="prefetch" href="/book/assets/js/150.8ab4f803.js"><link rel="prefetch" href="/book/assets/js/151.7c25e3a9.js"><link rel="prefetch" href="/book/assets/js/152.ef17e0ab.js"><link rel="prefetch" href="/book/assets/js/153.66076b2e.js"><link rel="prefetch" href="/book/assets/js/154.c5fb3b0f.js"><link rel="prefetch" href="/book/assets/js/155.d91cc7fa.js"><link rel="prefetch" href="/book/assets/js/156.2a84a2b9.js"><link rel="prefetch" href="/book/assets/js/157.f4d214f5.js"><link rel="prefetch" href="/book/assets/js/158.be218fd3.js"><link rel="prefetch" href="/book/assets/js/159.433d8420.js"><link rel="prefetch" href="/book/assets/js/16.9f90f744.js"><link rel="prefetch" href="/book/assets/js/160.943cc1a3.js"><link rel="prefetch" href="/book/assets/js/161.f6e3ee5a.js"><link rel="prefetch" href="/book/assets/js/162.bf279bcd.js"><link rel="prefetch" href="/book/assets/js/17.b8b34eba.js"><link rel="prefetch" href="/book/assets/js/18.af91aa32.js"><link rel="prefetch" href="/book/assets/js/19.323db867.js"><link rel="prefetch" href="/book/assets/js/20.cfa0aec5.js"><link rel="prefetch" href="/book/assets/js/21.6229732b.js"><link rel="prefetch" href="/book/assets/js/22.0075949b.js"><link rel="prefetch" href="/book/assets/js/23.fb025ad5.js"><link rel="prefetch" href="/book/assets/js/24.36f14df7.js"><link rel="prefetch" href="/book/assets/js/25.e0f6451f.js"><link rel="prefetch" href="/book/assets/js/26.dc431926.js"><link rel="prefetch" href="/book/assets/js/27.237a8e5f.js"><link rel="prefetch" href="/book/assets/js/28.4ef0a215.js"><link rel="prefetch" href="/book/assets/js/29.b434dc9b.js"><link rel="prefetch" href="/book/assets/js/30.72ff699c.js"><link rel="prefetch" href="/book/assets/js/31.a79e209c.js"><link rel="prefetch" href="/book/assets/js/32.0869bd1c.js"><link rel="prefetch" href="/book/assets/js/33.db31ca56.js"><link rel="prefetch" href="/book/assets/js/34.75da57c9.js"><link rel="prefetch" href="/book/assets/js/35.10ae92e8.js"><link rel="prefetch" href="/book/assets/js/36.73b85eab.js"><link rel="prefetch" href="/book/assets/js/37.cd9b41b0.js"><link rel="prefetch" href="/book/assets/js/38.43de425f.js"><link rel="prefetch" href="/book/assets/js/39.1dd2fbe4.js"><link rel="prefetch" href="/book/assets/js/40.1b68ef64.js"><link rel="prefetch" href="/book/assets/js/41.9e49e0cf.js"><link rel="prefetch" href="/book/assets/js/42.03fbcb0f.js"><link rel="prefetch" href="/book/assets/js/43.fe97e66d.js"><link rel="prefetch" href="/book/assets/js/44.90269fc6.js"><link rel="prefetch" href="/book/assets/js/45.7cb71ba0.js"><link rel="prefetch" href="/book/assets/js/46.ee091a2d.js"><link rel="prefetch" href="/book/assets/js/47.c58a3824.js"><link rel="prefetch" href="/book/assets/js/48.6a7c34b1.js"><link rel="prefetch" href="/book/assets/js/49.493683e6.js"><link rel="prefetch" href="/book/assets/js/5.c91de22c.js"><link rel="prefetch" href="/book/assets/js/50.532c274a.js"><link rel="prefetch" href="/book/assets/js/51.e333bb78.js"><link rel="prefetch" href="/book/assets/js/52.853c6004.js"><link rel="prefetch" href="/book/assets/js/53.e42cc193.js"><link rel="prefetch" href="/book/assets/js/54.4524c464.js"><link rel="prefetch" href="/book/assets/js/55.e4236b84.js"><link rel="prefetch" href="/book/assets/js/56.a9485332.js"><link rel="prefetch" href="/book/assets/js/57.1debe95a.js"><link rel="prefetch" href="/book/assets/js/58.9461e577.js"><link rel="prefetch" href="/book/assets/js/59.b88afba7.js"><link rel="prefetch" href="/book/assets/js/6.961a656a.js"><link rel="prefetch" href="/book/assets/js/60.87528566.js"><link rel="prefetch" href="/book/assets/js/61.0907f36e.js"><link rel="prefetch" href="/book/assets/js/62.f75b6320.js"><link rel="prefetch" href="/book/assets/js/63.11581819.js"><link rel="prefetch" href="/book/assets/js/64.6e01c8f8.js"><link rel="prefetch" href="/book/assets/js/65.86da1028.js"><link rel="prefetch" href="/book/assets/js/66.76b41ac7.js"><link rel="prefetch" href="/book/assets/js/67.73445576.js"><link rel="prefetch" href="/book/assets/js/68.5d563c69.js"><link rel="prefetch" href="/book/assets/js/69.cbcad7b9.js"><link rel="prefetch" href="/book/assets/js/7.e5eadd5e.js"><link rel="prefetch" href="/book/assets/js/70.2f2db2a2.js"><link rel="prefetch" href="/book/assets/js/71.0398ac26.js"><link rel="prefetch" href="/book/assets/js/72.2e571244.js"><link rel="prefetch" href="/book/assets/js/73.8fdece9d.js"><link rel="prefetch" href="/book/assets/js/74.22068dc5.js"><link rel="prefetch" href="/book/assets/js/75.468772e2.js"><link rel="prefetch" href="/book/assets/js/76.417b00cf.js"><link rel="prefetch" href="/book/assets/js/77.569c3ef1.js"><link rel="prefetch" href="/book/assets/js/78.8a649646.js"><link rel="prefetch" href="/book/assets/js/79.11b76a35.js"><link rel="prefetch" href="/book/assets/js/8.3201113b.js"><link rel="prefetch" href="/book/assets/js/80.7784e3a4.js"><link rel="prefetch" href="/book/assets/js/81.7a092123.js"><link rel="prefetch" href="/book/assets/js/82.5811a617.js"><link rel="prefetch" href="/book/assets/js/83.83712b60.js"><link rel="prefetch" href="/book/assets/js/84.81792bea.js"><link rel="prefetch" href="/book/assets/js/85.77fe68d2.js"><link rel="prefetch" href="/book/assets/js/86.c0554384.js"><link rel="prefetch" href="/book/assets/js/87.c7a91fbd.js"><link rel="prefetch" href="/book/assets/js/88.6cbb9486.js"><link rel="prefetch" href="/book/assets/js/89.d8cafb07.js"><link rel="prefetch" href="/book/assets/js/9.5cf4899a.js"><link rel="prefetch" href="/book/assets/js/90.ad729539.js"><link rel="prefetch" href="/book/assets/js/91.7e279ed0.js"><link rel="prefetch" href="/book/assets/js/92.91b4bfa4.js"><link rel="prefetch" href="/book/assets/js/93.9aad052b.js"><link rel="prefetch" href="/book/assets/js/94.b3947813.js"><link rel="prefetch" href="/book/assets/js/95.175853bf.js"><link rel="prefetch" href="/book/assets/js/96.a67ba26d.js"><link rel="prefetch" href="/book/assets/js/97.d1ef626d.js"><link rel="prefetch" href="/book/assets/js/98.68aa75ea.js"><link rel="prefetch" href="/book/assets/js/99.fcdaeecb.js"><link rel="prefetch" href="/book/assets/js/vendors~docsearch.c8693219.js">
    <link rel="stylesheet" href="/book/assets/css/0.styles.d473fa6d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book/" class="home-link router-link-active"><!----> <span class="site-name">日常收集</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dom的事件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Javascript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/338.html" class="sidebar-link"> JS异步编程——WebWorker多线程机制</a></li><li><a href="/book/337.html" class="sidebar-link">js</a></li><li><a href="/book/336.html" aria-current="page" class="active sidebar-link"> [核心概念] 一文说透JS中的原型和继承(上)</a></li><li><a href="/book/335.html" class="sidebar-link"> [关联概念] 一文说透 JS 中的变量提升</a></li><li><a href="/book/334.html" class="sidebar-link"> [核心概念] 一文说透浏览器环境下的JS运行机制</a></li><li><a href="/book/333.html" class="sidebar-link"> [核心概念] 一文说透JS中的函数柯里化(Currying)</a></li><li><a href="/book/332.html" class="sidebar-link"> [核心概念] 一文说透 JS 中 this 的基本概念</a></li><li><a href="/book/331.html" class="sidebar-link"> [核心概念] 一文说透 JS 的作用域（scope）</a></li><li><a href="/book/330.html" class="sidebar-link"> [核心概念] 一文说透 JS 中的闭包（closure）</a></li><li><a href="/book/329.html" class="sidebar-link"> [核心概念] 一文说透 JS 中的执行上下文</a></li><li><a href="/book/268.html" class="sidebar-link"> 「硬核JS」你真的了解垃圾回收机制吗</a></li><li><a href="/book/262.html" class="sidebar-link"> 「硬核JS」你的程序中可能存在内存泄漏</a></li><li><a href="/book/229.html" class="sidebar-link"> 聊聊JS的二进制家族：Blob、ArrayBuffer和Buffer</a></li><li><a href="/book/226.html" class="sidebar-link"> `Object.defineProperty()详解`</a></li><li><a href="/book/180.html" class="sidebar-link">yield是什么</a></li><li><a href="/book/175.html" class="sidebar-link">HTTP请求中，几种常见的Content-Type类型</a></li><li><a href="/book/172.html" class="sidebar-link"> js 给元素添加、删除父标签</a></li><li><a href="/book/171.html" class="sidebar-link"> 多个promise实现</a></li><li><a href="/book/131.html" class="sidebar-link"> Object.defineProperty和Object.defineProperties()</a></li><li><a href="/book/126.html" class="sidebar-link"> scrollHeight,scrollLeft,offsetHeight,offsetLeft</a></li><li><a href="/book/118.html" class="sidebar-link"> 怎样让 forEach 停下来呢；**try catch**</a></li><li><a href="/book/105.html" class="sidebar-link">div拖动的实现</a></li><li><a href="/book/93.html" class="sidebar-link">JavaScript对象之深拷贝和浅拷贝</a></li><li><a href="/book/92.html" class="sidebar-link">base64。js</a></li><li><a href="/book/85.html" class="sidebar-link">你也许不知道的JavaScript高级函数</a></li><li><a href="/book/78.html" class="sidebar-link">ESmodules:Acartoondeep-dive</a></li><li><a href="/book/73.html" class="sidebar-link">setTimeout和setImmediate到底谁先执行，本文让你彻底理解EventLoop</a></li><li><a href="/book/71.html" class="sidebar-link">一种对开发更友好的前端骨架屏自动生成方案</a></li><li><a href="/book/68.html" class="sidebar-link">深入理解ESModules(手绘示例)</a></li><li><a href="/book/48.html" class="sidebar-link">系统学习前端之FormData详解</a></li><li><a href="/book/47.html" class="sidebar-link">使用FormData上传文件</a></li><li><a href="/book/46.html" class="sidebar-link">数组排序方法</a></li><li><a href="/book/43.html" class="sidebar-link">利于FileReader实现二进制数据流转JSON</a></li><li><a href="/book/28.html" class="sidebar-link">reduce过滤数组中重复对象</a></li><li><a href="/book/27.html" class="sidebar-link">常用文件类型对应</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>element-ui</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Qcanvas</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/328.html" class="sidebar-link"> 从哲学层面浅谈计算机学习方法论</a></li><li><a href="/book/324.html" class="sidebar-link"> 微信游览器，解决安卓和ios自动播放音乐</a></li><li><a href="/book/323.html" class="sidebar-link"> CSS3 animation属性中的steps功能符深入介绍</a></li><li><a href="/book/322.html" class="sidebar-link"> 前端搞工程化：从零打造性能检测库「源码 + 视频」</a></li><li><a href="/book/321.html" class="sidebar-link"> 还在看那些老掉牙的性能优化文章么？这些最新性能指标了解下</a></li><li><a href="/book/320.html" class="sidebar-link"> Nginx根据User Agent动态配置root目录适配移动端</a></li><li><a href="/book/307.html" class="sidebar-link"> cat文档内容中搜索字符串输出到文件</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/301.html" class="sidebar-link">从App store下载App的不同版本ipa文件----很多东西也不是越新越好，比如APP——在 iPhone 上尤其如此</a></li><li><a href="/book/294.html" class="sidebar-link">迟子建老师的《一坛猪油》</a></li><li><a href="/book/288.html" class="sidebar-link">文本文档的协同编辑实现</a></li><li><a href="/book/287.html" class="sidebar-link">再见，整洁代码</a></li><li><a href="/book/286.html" class="sidebar-link"> 可以在 Nginx 中运行 JavaScript，厉害了！</a></li><li><a href="/book/284.html" class="sidebar-link"> word中批量调整图片大小</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>electron打包的一些问题</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/274.html" class="sidebar-link"> 文件分片代码</a></li><li><a href="/book/273.html" class="sidebar-link"> 重学 JS：为啥 await 不能用在 forEach 中详解</a></li><li><a href="/book/269.html" class="sidebar-link"> Excel函数之王，Vlookup到底怎么用？</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mysql</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/248.html" class="sidebar-link"> 《提问的智慧》精读注解版</a></li><li><a href="/book/199.html" class="sidebar-link"> js监听div的resize事件</a></li><li><a href="/book/198.html" class="sidebar-link"> 引入第三方字体体积太大的问题</a></li><li><a href="/book/195.html" class="sidebar-link"> 多行溢出省略号显示（css/js）实现！</a></li><li><a href="/book/190.html" class="sidebar-link">今天带大家一起来看看下，如何实现“划词高亮”功能。</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Canvas</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工作中解决的疑难问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>nginx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/135.html" class="sidebar-link"> 深夜，我偷听到程序员要对session下手</a></li><li><a href="/book/132.html" class="sidebar-link"> 读 《深入浅出webpack》</a></li><li><a href="/book/103.html" class="sidebar-link"> 一道被人轻视的前端面试题</a></li><li><a href="/book/101.html" class="sidebar-link">部分前端面试题参考答案</a></li><li><a href="/book/80.html" class="sidebar-link">SVGDeveloper制作矢量地图教程详解</a></li><li><a href="/book/76.html" class="sidebar-link">VisualStudio2010创建的WCF（.dll）服务第一个应用</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="核心概念-一文说透js中的原型和继承-上"><a href="#核心概念-一文说透js中的原型和继承-上" class="header-anchor">#</a> [核心概念] 一文说透JS中的原型和继承(上)</h1> <h2 id="系列开篇"><a href="#系列开篇" class="header-anchor">#</a> 系列开篇</h2> <blockquote><p>为进入前端的你建立<strong>清晰、准确、必要</strong>的<strong>概念</strong>和这些概念的之间<strong>清晰、准确、必要</strong>的<strong>关联</strong>, 让你不管在什么面试中都能淡定从容。没有目录，而是通过概念关联形成了一张知识网络，往下看你就明白了。当你遇到【关联概念】时，可先从括号中的(强/弱)判断简单这个关联是对你正在理解的概念是强相关(得先理解你才能继续往下)还是弱相关(知识拓展)从而提高你的阅读效率。我也会定期更新相关关联概念。</p></blockquote> <h3 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h3> <ul><li>什么是原型，原型链</li> <li>js中是如何实现继承关系的（基于原型链的继承）</li> <li><code>[[Prototype]] 、__proto__ 、 prototype属性、constructor</code> 等等都是干啥的</li> <li>我们平时能用这些个知识做些什么事</li> <li>js 的面向对象思想</li></ul> <h1 id="这是干什么的"><a href="#这是干什么的" class="header-anchor">#</a> 这是干什么的？</h1> <p>我们先给个MDN上的定义，帮助我们初步了解这些概念，以及这些概念的关联。</p> <blockquote><p>MDN: JavaScript 常被描述为一种<strong>基于原型的语言</strong> (<code>prototype-based language</code>)——每个对象拥有一个<strong>原型对象</strong>，<strong>对象以其原型为 <code>模板</code>、从原型 <code>继承方法和属性</code></strong>。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链</strong> (<code>prototype chain</code>)，它解释了 <code>为何一个对象会拥有定义在其他对象中的属性和方法</code>。</p></blockquote> <p>在传统的面向对象编程 (OOP) 中，首先定义“<strong>类</strong>” (Class)，此后创建对象实例时，类中定义的所有属性和方法都被<strong>复制到实例</strong>中。在 JavaScript 中<strong>并不如此复制</strong>——而是在对象实例和它的构造器之间建立一个链接（它是 <code>__proto__</code>属性，是从构造函数的prototype属性派生的），之后通过<strong>上溯原型链</strong>，在<strong>构造器中找到这些属性和方法</strong>。</p> <p>ok 我们现在先留下一个大致印象。模糊的了解了什么是<strong>原型和原型链</strong>。</p> <h2 id="原型继承"><a href="#原型继承" class="header-anchor">#</a> 原型继承</h2> <p>在编程中，我们经常会想获取并<strong>扩展</strong>一些东西，这非常常见，比如你有 <code>people</code> 这个对象及其属性和方法，并希望将 <code>student</code> 和 <code>worker</code> 作为基于 <code>people</code> <strong>稍加修改的变体</strong>。我们想 <code>重用</code> <code>people</code> 中的内容，<strong>而不是复制/重新实现</strong>它的方法，而只是在其之上构建一个新的对象。<strong>原型继承</strong>（Prototypal inheritance） 这个语言特性能够帮助我们实现这一需求。</p> <h3 id="prototype"><a href="#prototype" class="header-anchor">#</a> <code>[[Prototype]]</code></h3> <p>在 JavaScript 中，对象有一个特殊的<strong>隐藏属性</strong> <code>[[Prototype]]</code>，它要么为 <code>null</code>，要么就是 <code>对另一个对象的引用</code>。该对象被称为“<strong>原型</strong>”, 也可以理解为这个属性是<strong>指向原型对象的指针</strong>。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3084262f1e8e4fdcb1588a2418fd45d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p> <p>就像这样，当我们从 object 中读取一个<strong>缺失</strong>的属性时，JavaScript 会自动从<strong>原型对象</strong>中获取该属性。</p> <h3 id="proto"><a href="#proto" class="header-anchor">#</a> <code>__proto__</code></h3> <p>我们可以用 <code>__proto__</code>来设置 <code>[[Prototype]]</code>这个隐藏属性。不过现在有新的访问方式。
<code>__proto__</code> 是 <code>[[Prototype]]</code>属性由于历史原因而留下来的 <code>getter/setter</code>。</p> <blockquote><p>MDN: 遵循ECMAScript标准，<code>someObject.[[Prototype]]</code> 符号是用于指向 someObject 的原型。从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p></blockquote> <p>首先明确这不是一个东西。再强调 <code>__proto__</code> 是 <code>[[Prototype]]</code> 的 <code>getter/setter</code>。
但由于 <code>__proto__</code> 标记在观感上更加明显，所以我们在下面的示例中将使用它。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">eats</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">jumps</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 设置 rabbit.[[Prototype]] = animal</span>
rabbit<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> animal<span class="token punctuation">;</span> 
复制代码
</code></pre></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93853c07481e473295b2fe6facfd5e7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p> <p>可以说 <code>animal</code> 是 <code>rabbit</code> 的 <code>原型</code>，或者说 <code>rabbit</code> 的 <code>原型</code>是从 <code>animal</code> <code>继承</code>而来的。</p> <p>现在，如果我们从 rabbit 中读取一个它没有的属性，JavaScript 会自动从 animal 中获取。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
复制代码
</code></pre></div><p>当 alert 试图读取 <code>rabbit.eats</code> 时，因为它<strong>不存在于 rabbit 中</strong>，所以 JavaScript 会顺着 <code>[[Prototype]]</code> 引用，在 <code>animal</code> 中查找（自下而上）</p> <p>因此，如果 <code>animal</code> 中有许多<strong>有用的属性和方法</strong>，那么它们将<strong>自动地变为在 <code>rabbit</code> 中可用</strong>。这种属性被称为“<strong>继承</strong>”。</p> <p>例如如果我们在 animal 中有一个<strong>方法</strong>，它也可以在 rabbit 中被调用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">eats</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Animal walk&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">jumps</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> animal
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// walk 方法是从原型中获得的</span>
rabbit<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Animal walk</span>
复制代码
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0624329b767a430ba5a4f3f55c25b0bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p> <p>原型链可以很长，原型还能有原型，但<strong>不能有闭环</strong>，如果我们试图在一个闭环中分配 <code>__proto__</code>，JavaScript 会抛出错误。并且只能有一个 <code>[[Prototype]]</code>。一个对象<strong>不能从其他两个对象</strong>获得继承。这跟OOP的<strong>多重继承</strong> [核心概念] 不同 。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816a968e901d46ae8402f3730ad5c5f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p> <p>现在我们对原型和原型链有了更进一步的认识。当<strong>读取实例的属性</strong>时，如果找不到，就会查找与 <code>对象关联的原型</code><strong>中的属性</strong>，如果还查不到，就<strong>去找原型的原型</strong>，一直<strong>找到最顶层为止</strong>。</p> <h2 id="f-prototype"><a href="#f-prototype" class="header-anchor">#</a> F.prototype</h2> <p>我们现在知道，一个对象可能是另一个对象的原型，那么平时我们如何创建对象的?</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 字面量，没毛病</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// new 关键字</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>

<span class="token comment">// 又或者 Object.create 等等</span>
复制代码
</code></pre></div><p>我们来讨论下 <code>new F</code> 这样的用<strong>构造函数</strong>来创建一个新对象。</p> <p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会<strong>使用它为新对象设置</strong> <code>[[Prototype]]</code>。</p> <p>也就是说，<code>F.prototype</code> 这个属性指向的是一个对象(假设是A)，那么 用 <code>let b = new F()</code> 创建的实例(b)的 <code>[[Prototype]]</code> 就指向这个对象(A)，也就是作为这个新实例的<strong>原型对象</strong>(A)</p> <p>注意，这里的 <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 &quot;prototype&quot; 的<strong>常规属性</strong>。</p> <p>看个具体例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">eats</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 构造函数的 prototype 属性设置为 animal</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> animal<span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token string">&quot;White Rabbit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  rabbit.__proto__ == animal</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
复制代码
</code></pre></div><p>设置 <code>Rabbit.prototype = animal</code> 的字面意思是：“当创建了一个 <code>new Rabbit</code> 时，把它的 <code>[[Prototype]]</code> 赋值为 <code>animal</code>”。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f17cea8c8c4479092973743ca796846~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <p>在上图中，&quot;prototype&quot; 是一个水平箭头，表示一个<strong>常规属性</strong>，<code>[[Prototype]]</code> 是垂直的，表示 <code>rabbit</code> <strong>继承</strong>自 <code>animal</code>, 或者说 <code>animal</code> 是 <code>rabbit</code> 的<strong>原型</strong>。</p> <p>所以结论是：<code>F.prototype</code> <strong>属性仅在 <code>new F</code> 被调用时使用</strong>，它为<strong>新对象</strong>的 <code>[[Prototype]]</code> <strong>赋值</strong>。</p> <p>另外 <code>F.prototype</code> 的值要么是一个<strong>对象</strong>，要么就是 <strong>null</strong>：<strong>其他值都不起作用</strong>。</p> <p>但我们平时貌似没手动给 <code>new F</code>加过 <code>prototype</code> 这个属性啊，因为 js 给我们加了个默认选项，也就是 <strong>默认的 F.prototype</strong>，<strong>构造器属性</strong></p> <p>每个 <code>函数</code>都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</p> <p>默认的 <code>&quot;prototype&quot;</code> 是一个<strong>只有属性</strong> <code>constructor</code> <strong>的对象</strong>，属性 constructor <strong>指向函数自身</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">/* default prototype
Rabbit.prototype = { constructor: Rabbit };
*/</span>
复制代码
</code></pre></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e7a0bc7af54b03a34b3c4da41df712~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <p>我们可以检查一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// by default:</span>
<span class="token comment">// Rabbit.prototype = { constructor: Rabbit }</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Rabbit <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 而且 constructor 属性可以通过 [[Prototype]] 给所有实例 rabbits 使用：</span>
<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inherits from {constructor: Rabbit}</span>

<span class="token function">alert</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Rabbit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (from prototype)</span>
复制代码
</code></pre></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9564cd0d145249c791b1f41efba0c70f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <p>所以我们可以使用 <code>constructor</code> 属性来<strong>创建一个新对象</strong>，该对象使用与现有对象相同的构造器。类似 <code>new rabbit.constructor();</code> 这样。</p> <p>这里有个点一定要注意：<strong>JavaScript 自身并不能确保正确的 &quot;constructor&quot; 函数值</strong>。如果我们将整个默认 prototype 替换掉，那么其中就不会有 &quot;constructor&quot; 了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">jumps</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Rabbit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
复制代码
</code></pre></div><p>所以在操作原型对象时，<strong>切忌直接替换</strong>，我们可以选择添加/删除属性到默认 &quot;prototype&quot;。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 不要将 Rabbit.prototype 整个覆盖</span>
<span class="token comment">// 可以向其中添加内容</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>jumps <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token comment">// 默认的 Rabbit.prototype.constructor 被保留了下来</span>

<span class="token comment">// 或者，也可以手动重新创建 constructor 属性</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">jumps</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">constructor</span><span class="token operator">:</span> Rabbit
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 这样的 constructor 也是正确的，因为我们手动添加了它</span>
复制代码
</code></pre></div><h2 id="原生的原型"><a href="#原生的原型" class="header-anchor">#</a> 原生的原型</h2> <p><strong><code>prototype</code></strong> 属性在 JavaScript 自身的核心部分中被广泛地应用。<strong>所有的内置构造函数</strong>都用到了它。</p> <h3 id="object-prototype"><a href="#object-prototype" class="header-anchor">#</a> Object.prototype</h3> <p>假如我们输出一个空对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Object]&quot;</span>
复制代码
</code></pre></div><p>生成字符串 <code>&quot;[object Object]&quot;</code> 的代码在哪里？</p> <p><code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思，其中 Object 就是一个<strong>内建的对象构造函数</strong>，其自身的 <code>prototype</code> 指向一个带有 toString 和其他方法的一个巨大的对象。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9da4f0542f840938fc0f7217151111b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <p>所以, 当 <code>obj.toString()</code> 被调用时，这个方法是从 <code>Object.prototype</code> 中获取的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token function">alert</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>toString <span class="token operator">===</span> obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>toString <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token comment">// 请注意在 Object.prototype 上方的链中没有更多的 [[Prototype]]</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>
复制代码
</code></pre></div><p>其他内建对象，像 <code>Array、Date、Function 及其他</code>，都在 <code>prototype</code> 上挂载了方法。我们看个完整点的</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd28b17ab1e4f71a887f3e7acaca6a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <h3 id="基本数据类型的特殊性"><a href="#基本数据类型的特殊性" class="header-anchor">#</a> 基本数据类型的特殊性</h3> <p>我们看个例子</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>
复制代码
</code></pre></div><p><code>&quot;123&quot;</code> 不是个字符串基本类型吗，并不是对象，为什么能调用 <code>split</code> 方法?</p> <p>答案是 <strong>临时包装器对象</strong></p> <p><code>字符串</code>、<code>数字</code>和 <code>布尔值</code>虽然是<strong>基本类型</strong>但是如果我们试图访问它们的属性，那么<strong>临时包装器对象</strong>将会通过<strong>内建的构造器</strong> <code>String、Number 和 Boolean 被创建</code>。那么这些方法存储在包装器对象的 prototype 中：<code>String.prototype、Number.prototype 和 Boolean.prototype</code>。它们提供给我们操作字符串、数字和布尔值的方法<strong>然后消失</strong>。</p> <p>注意原始数据类型只有 <code>undefined 和 null</code> <strong>没有包装器对象</strong>。所以它们<strong>没有方法和属性</strong>。并且它们<strong>也没有相应的原型</strong>。</p> <p>另外内建原型<strong>可以被修改</strong>或被用新的方法填充。但是<strong>不建议更改它们</strong>。</p> <h1 id="原型链图解析"><a href="#原型链图解析" class="header-anchor">#</a> 原型链图解析</h1> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ef7b70f27947198146c4ad58b18f06~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p> <p>现在理解原型相关概念后，我们来看下这个图，简单分三部分</p> <ul><li>上面绿色箭头相关部分</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Foo 是个构造方法</span>
<span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// f1 f2 是 Foo 这个构造函数 创建的对象实例</span>
<span class="token keyword">let</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 它们的 [[Prototype]] 或者说 __proto__ 指向 Foo.prototype 这个原型对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 默认的 prototype 是一个只有属性constructor 的对象，属性 constructor 指向函数自身。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
复制代码
</code></pre></div><ul><li>中间蓝色箭头相关部分</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// o1 o2 是普通对象创建方式可以这样，实际一个效果</span>
<span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 其中 Object 就是一个 内建的对象构造函数</span>
<span class="token comment">// 其自身的 prototype 指向一个带有 toString 和其他方法的一个巨大的对象。</span>

<span class="token comment">//  类似的 他们的原型 就是 Object.prototype</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// Object.prototype 上方的链中没有更多的 [[Prototype]]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// 原型对象的 constructor 属性还是指向构造函数自身。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token comment">// true</span>
复制代码
</code></pre></div><ul><li>下方红色箭头相关部分</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 只要是个函数 他的__proto__都是指向 Function.prototype</span>
<span class="token comment">// 可以理解为函数是 new Function() 出来的对象实例</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
复制代码
</code></pre></div><p>相信这张图，你现在看起来会觉得异常清晰。</p> <p>另外面试中常考的相关手写方案请看这篇 前端面试必刷手写题系列[4]，是关于 <code>instanceof</code>和 <code>new 关键字</code> 的<strong>手写实现</strong>。</p> <p>理解原型之后，我们下篇再说<strong>Javascript中的继承</strong>[核心概念]</p> <hr> <blockquote><p>继续下去，你总会有收获。
上面这句话给你们，同样也给我自己前进的动力。</p></blockquote> <p>我是摩尔，数学专业，做过互联网研发，测试，产品</p> <p>致力用技术改变别人的生活，用梦想改变自己的生活</p> <p>关注我，找到自己的互联网思路，踏实地打牢固自己的技术体系</p> <p><code>点赞、关注、评论、谢谢</code></p> <p>有问题求助可私信 <strong>1602111431@qq.com</strong> 我会尽可能帮助你，也可以<strong>交个朋友</strong></p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li>You don't know Javascript 上卷</li> <li>zh.javascript.info/prototype-i…</li> <li>developer.mozilla.org/zh-CN/docs/…</li></ul> <p>.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}
文章来源：https://juejin.cn/post/6963251911046725669</p> <!----></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/337.html" class="prev">
        js
      </a></span> <span class="next"><a href="/book/335.html">
         [关联概念] 一文说透 JS 中的变量提升
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><section class="side-anchor"><ul style="display:none;"></ul></section></div></div>
    <script src="/book/assets/js/app.a5076a9c.js" defer></script><script src="/book/assets/js/3.0d5fb1e8.js" defer></script><script src="/book/assets/js/127.fa6f9e4f.js" defer></script><script src="/book/assets/js/4.4c5f7830.js" defer></script>
  </body>
</html>
