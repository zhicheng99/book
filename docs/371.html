<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript操作DOM常用的API | 日常收集</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/book/assets/css/0.styles.0575b83d.css" as="style"><link rel="preload" href="/book/assets/js/app.5040eec0.js" as="script"><link rel="preload" href="/book/assets/js/3.0d5fb1e8.js" as="script"><link rel="preload" href="/book/assets/js/150.a81273ed.js" as="script"><link rel="preload" href="/book/assets/js/4.4c5f7830.js" as="script"><link rel="prefetch" href="/book/assets/js/10.03e42995.js"><link rel="prefetch" href="/book/assets/js/100.6437bccb.js"><link rel="prefetch" href="/book/assets/js/101.5440e694.js"><link rel="prefetch" href="/book/assets/js/102.d066b8fb.js"><link rel="prefetch" href="/book/assets/js/103.60d2cdd2.js"><link rel="prefetch" href="/book/assets/js/104.cc97244d.js"><link rel="prefetch" href="/book/assets/js/105.6bbaec44.js"><link rel="prefetch" href="/book/assets/js/106.c3b4924e.js"><link rel="prefetch" href="/book/assets/js/107.7dcac7a5.js"><link rel="prefetch" href="/book/assets/js/108.bb63280d.js"><link rel="prefetch" href="/book/assets/js/109.7b7f2e3a.js"><link rel="prefetch" href="/book/assets/js/11.44217601.js"><link rel="prefetch" href="/book/assets/js/110.344c349d.js"><link rel="prefetch" href="/book/assets/js/111.ded9790a.js"><link rel="prefetch" href="/book/assets/js/112.536dc07f.js"><link rel="prefetch" href="/book/assets/js/113.d14d5801.js"><link rel="prefetch" href="/book/assets/js/114.33fadcf1.js"><link rel="prefetch" href="/book/assets/js/115.33921643.js"><link rel="prefetch" href="/book/assets/js/116.8b98cc62.js"><link rel="prefetch" href="/book/assets/js/117.57e7cda5.js"><link rel="prefetch" href="/book/assets/js/118.4cca96d1.js"><link rel="prefetch" href="/book/assets/js/119.5af2dd1c.js"><link rel="prefetch" href="/book/assets/js/12.571f12ac.js"><link rel="prefetch" href="/book/assets/js/120.4d8016fe.js"><link rel="prefetch" href="/book/assets/js/121.dc41fffa.js"><link rel="prefetch" href="/book/assets/js/122.60e9d0a0.js"><link rel="prefetch" href="/book/assets/js/123.f0183da7.js"><link rel="prefetch" href="/book/assets/js/124.6982191c.js"><link rel="prefetch" href="/book/assets/js/125.17f3f2f4.js"><link rel="prefetch" href="/book/assets/js/126.5d06ad3c.js"><link rel="prefetch" href="/book/assets/js/127.8a01caf7.js"><link rel="prefetch" href="/book/assets/js/128.833eb16c.js"><link rel="prefetch" href="/book/assets/js/129.ade4c04a.js"><link rel="prefetch" href="/book/assets/js/13.5ef8e835.js"><link rel="prefetch" href="/book/assets/js/130.36067eb9.js"><link rel="prefetch" href="/book/assets/js/131.7486cd20.js"><link rel="prefetch" href="/book/assets/js/132.c9566b96.js"><link rel="prefetch" href="/book/assets/js/133.1a253cb2.js"><link rel="prefetch" href="/book/assets/js/134.fd4dd490.js"><link rel="prefetch" href="/book/assets/js/135.dbe02774.js"><link rel="prefetch" href="/book/assets/js/136.5bbded3d.js"><link rel="prefetch" href="/book/assets/js/137.9b69ce3a.js"><link rel="prefetch" href="/book/assets/js/138.9c610e7f.js"><link rel="prefetch" href="/book/assets/js/139.dccc188d.js"><link rel="prefetch" href="/book/assets/js/14.3d533f57.js"><link rel="prefetch" href="/book/assets/js/140.1eda4021.js"><link rel="prefetch" href="/book/assets/js/141.4d033422.js"><link rel="prefetch" href="/book/assets/js/142.5f3579b5.js"><link rel="prefetch" href="/book/assets/js/143.1c68a47a.js"><link rel="prefetch" href="/book/assets/js/144.95d3b900.js"><link rel="prefetch" href="/book/assets/js/145.89d4d536.js"><link rel="prefetch" href="/book/assets/js/146.9765de5b.js"><link rel="prefetch" href="/book/assets/js/147.c167f141.js"><link rel="prefetch" href="/book/assets/js/148.e4d5f2d7.js"><link rel="prefetch" href="/book/assets/js/149.2c5cedbc.js"><link rel="prefetch" href="/book/assets/js/15.64e47055.js"><link rel="prefetch" href="/book/assets/js/151.438c6f99.js"><link rel="prefetch" href="/book/assets/js/152.153fe68f.js"><link rel="prefetch" href="/book/assets/js/153.ca7c6b6c.js"><link rel="prefetch" href="/book/assets/js/154.fbdafb90.js"><link rel="prefetch" href="/book/assets/js/155.7fb8e83d.js"><link rel="prefetch" href="/book/assets/js/156.7034c74f.js"><link rel="prefetch" href="/book/assets/js/157.3668386c.js"><link rel="prefetch" href="/book/assets/js/158.eb328af9.js"><link rel="prefetch" href="/book/assets/js/159.6a41e30b.js"><link rel="prefetch" href="/book/assets/js/16.21614f1d.js"><link rel="prefetch" href="/book/assets/js/160.337c8dd4.js"><link rel="prefetch" href="/book/assets/js/161.a84f8652.js"><link rel="prefetch" href="/book/assets/js/162.45b1e456.js"><link rel="prefetch" href="/book/assets/js/163.148ee88f.js"><link rel="prefetch" href="/book/assets/js/164.ee34bc8f.js"><link rel="prefetch" href="/book/assets/js/165.b7ab2a0f.js"><link rel="prefetch" href="/book/assets/js/166.fc86defd.js"><link rel="prefetch" href="/book/assets/js/167.bdc1ff67.js"><link rel="prefetch" href="/book/assets/js/168.509f8f50.js"><link rel="prefetch" href="/book/assets/js/169.92f44b0a.js"><link rel="prefetch" href="/book/assets/js/17.b8b34eba.js"><link rel="prefetch" href="/book/assets/js/170.ce2d6156.js"><link rel="prefetch" href="/book/assets/js/171.10104fea.js"><link rel="prefetch" href="/book/assets/js/172.39350c36.js"><link rel="prefetch" href="/book/assets/js/173.cd3709d9.js"><link rel="prefetch" href="/book/assets/js/174.a91c1d49.js"><link rel="prefetch" href="/book/assets/js/175.c4441191.js"><link rel="prefetch" href="/book/assets/js/176.f68468e0.js"><link rel="prefetch" href="/book/assets/js/18.68a1d4d3.js"><link rel="prefetch" href="/book/assets/js/19.323db867.js"><link rel="prefetch" href="/book/assets/js/20.cfa0aec5.js"><link rel="prefetch" href="/book/assets/js/21.6229732b.js"><link rel="prefetch" href="/book/assets/js/22.6cc91e41.js"><link rel="prefetch" href="/book/assets/js/23.fb025ad5.js"><link rel="prefetch" href="/book/assets/js/24.36f14df7.js"><link rel="prefetch" href="/book/assets/js/25.eca0455e.js"><link rel="prefetch" href="/book/assets/js/26.cdaab27d.js"><link rel="prefetch" href="/book/assets/js/27.e436033e.js"><link rel="prefetch" href="/book/assets/js/28.9e463677.js"><link rel="prefetch" href="/book/assets/js/29.da1c1051.js"><link rel="prefetch" href="/book/assets/js/30.64a7a28d.js"><link rel="prefetch" href="/book/assets/js/31.5caab6ef.js"><link rel="prefetch" href="/book/assets/js/32.52c8742c.js"><link rel="prefetch" href="/book/assets/js/33.12aba373.js"><link rel="prefetch" href="/book/assets/js/34.75da57c9.js"><link rel="prefetch" href="/book/assets/js/35.ee075cac.js"><link rel="prefetch" href="/book/assets/js/36.b5344dc9.js"><link rel="prefetch" href="/book/assets/js/37.f96e5b12.js"><link rel="prefetch" href="/book/assets/js/38.8ed1081f.js"><link rel="prefetch" href="/book/assets/js/39.0bd213ce.js"><link rel="prefetch" href="/book/assets/js/40.6599c5e0.js"><link rel="prefetch" href="/book/assets/js/41.97b2afb2.js"><link rel="prefetch" href="/book/assets/js/42.f3817fc1.js"><link rel="prefetch" href="/book/assets/js/43.e68b91f3.js"><link rel="prefetch" href="/book/assets/js/44.1ae9f752.js"><link rel="prefetch" href="/book/assets/js/45.053c3252.js"><link rel="prefetch" href="/book/assets/js/46.afa3e05e.js"><link rel="prefetch" href="/book/assets/js/47.c58a3824.js"><link rel="prefetch" href="/book/assets/js/48.3d5aef2d.js"><link rel="prefetch" href="/book/assets/js/49.493683e6.js"><link rel="prefetch" href="/book/assets/js/5.a3244244.js"><link rel="prefetch" href="/book/assets/js/50.c538f846.js"><link rel="prefetch" href="/book/assets/js/51.e4519073.js"><link rel="prefetch" href="/book/assets/js/52.8e4a8eb5.js"><link rel="prefetch" href="/book/assets/js/53.bf8a944f.js"><link rel="prefetch" href="/book/assets/js/54.94af7e7a.js"><link rel="prefetch" href="/book/assets/js/55.3c6a8ec0.js"><link rel="prefetch" href="/book/assets/js/56.4879d74b.js"><link rel="prefetch" href="/book/assets/js/57.a22bdb49.js"><link rel="prefetch" href="/book/assets/js/58.49544dc5.js"><link rel="prefetch" href="/book/assets/js/59.b88afba7.js"><link rel="prefetch" href="/book/assets/js/6.18aff54a.js"><link rel="prefetch" href="/book/assets/js/60.22aa4a5b.js"><link rel="prefetch" href="/book/assets/js/61.0907f36e.js"><link rel="prefetch" href="/book/assets/js/62.5c4d287f.js"><link rel="prefetch" href="/book/assets/js/63.e23f1c3f.js"><link rel="prefetch" href="/book/assets/js/64.3324737d.js"><link rel="prefetch" href="/book/assets/js/65.86da1028.js"><link rel="prefetch" href="/book/assets/js/66.fb8a17cd.js"><link rel="prefetch" href="/book/assets/js/67.f4de38b9.js"><link rel="prefetch" href="/book/assets/js/68.c36038ef.js"><link rel="prefetch" href="/book/assets/js/69.ca13cfb5.js"><link rel="prefetch" href="/book/assets/js/7.637d308b.js"><link rel="prefetch" href="/book/assets/js/70.36531471.js"><link rel="prefetch" href="/book/assets/js/71.0398ac26.js"><link rel="prefetch" href="/book/assets/js/72.593c11c2.js"><link rel="prefetch" href="/book/assets/js/73.95a0d8b1.js"><link rel="prefetch" href="/book/assets/js/74.22068dc5.js"><link rel="prefetch" href="/book/assets/js/75.6fea3cc7.js"><link rel="prefetch" href="/book/assets/js/76.1607821a.js"><link rel="prefetch" href="/book/assets/js/77.90dd4bd2.js"><link rel="prefetch" href="/book/assets/js/78.d30f63dd.js"><link rel="prefetch" href="/book/assets/js/79.d6ca52ed.js"><link rel="prefetch" href="/book/assets/js/8.3201113b.js"><link rel="prefetch" href="/book/assets/js/80.928abd5f.js"><link rel="prefetch" href="/book/assets/js/81.48d40656.js"><link rel="prefetch" href="/book/assets/js/82.cae56c22.js"><link rel="prefetch" href="/book/assets/js/83.f7b8fe61.js"><link rel="prefetch" href="/book/assets/js/84.52d944b4.js"><link rel="prefetch" href="/book/assets/js/85.6f911071.js"><link rel="prefetch" href="/book/assets/js/86.3a2f1dd2.js"><link rel="prefetch" href="/book/assets/js/87.c7a91fbd.js"><link rel="prefetch" href="/book/assets/js/88.cf59763b.js"><link rel="prefetch" href="/book/assets/js/89.d8cafb07.js"><link rel="prefetch" href="/book/assets/js/9.5cf4899a.js"><link rel="prefetch" href="/book/assets/js/90.1bab1d5f.js"><link rel="prefetch" href="/book/assets/js/91.b97f9294.js"><link rel="prefetch" href="/book/assets/js/92.dbae4085.js"><link rel="prefetch" href="/book/assets/js/93.afd1d9c1.js"><link rel="prefetch" href="/book/assets/js/94.a6d57b47.js"><link rel="prefetch" href="/book/assets/js/95.dba426bb.js"><link rel="prefetch" href="/book/assets/js/96.e98dde02.js"><link rel="prefetch" href="/book/assets/js/97.12cc053e.js"><link rel="prefetch" href="/book/assets/js/98.38cf0aaa.js"><link rel="prefetch" href="/book/assets/js/99.3c666611.js"><link rel="prefetch" href="/book/assets/js/vendors~docsearch.c8693219.js">
    <link rel="stylesheet" href="/book/assets/css/0.styles.0575b83d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book/" class="home-link router-link-active"><!----> <span class="site-name">日常收集</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dom的事件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Javascript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/371.html" aria-current="page" class="active sidebar-link"> JavaScript操作DOM常用的API</a></li><li><a href="/book/366.html" class="sidebar-link"> JavaScript 内存泄漏</a></li><li><a href="/book/363.html" class="sidebar-link"> 让 JavaScript 在 WebAssembly 上加速运行！</a></li><li><a href="/book/361.html" class="sidebar-link"> 《程序员数学：位运算》——如何使用二进制计算乘法？</a></li><li><a href="/book/360.html" class="sidebar-link"> 速记：一个http请求的全过程是怎样的？</a></li><li><a href="/book/359.html" class="sidebar-link"> 万字扫盲ByteBuffer</a></li><li><a href="/book/338.html" class="sidebar-link"> JS异步编程——WebWorker多线程机制</a></li><li><a href="/book/337.html" class="sidebar-link">js</a></li><li><a href="/book/336.html" class="sidebar-link"> [核心概念] 一文说透JS中的原型和继承(上)</a></li><li><a href="/book/335.html" class="sidebar-link"> [关联概念] 一文说透 JS 中的变量提升</a></li><li><a href="/book/334.html" class="sidebar-link"> [核心概念] 一文说透浏览器环境下的JS运行机制</a></li><li><a href="/book/333.html" class="sidebar-link"> [核心概念] 一文说透JS中的函数柯里化(Currying)</a></li><li><a href="/book/332.html" class="sidebar-link"> [核心概念] 一文说透 JS 中 this 的基本概念</a></li><li><a href="/book/331.html" class="sidebar-link"> [核心概念] 一文说透 JS 的作用域（scope）</a></li><li><a href="/book/330.html" class="sidebar-link"> [核心概念] 一文说透 JS 中的闭包（closure）</a></li><li><a href="/book/329.html" class="sidebar-link"> [核心概念] 一文说透 JS 中的执行上下文</a></li><li><a href="/book/268.html" class="sidebar-link"> 「硬核JS」你真的了解垃圾回收机制吗</a></li><li><a href="/book/262.html" class="sidebar-link"> 「硬核JS」你的程序中可能存在内存泄漏</a></li><li><a href="/book/229.html" class="sidebar-link"> 聊聊JS的二进制家族：Blob、ArrayBuffer和Buffer</a></li><li><a href="/book/226.html" class="sidebar-link"> `Object.defineProperty()详解`</a></li><li><a href="/book/180.html" class="sidebar-link">yield是什么</a></li><li><a href="/book/175.html" class="sidebar-link">HTTP请求中，几种常见的Content-Type类型</a></li><li><a href="/book/172.html" class="sidebar-link"> js 给元素添加、删除父标签</a></li><li><a href="/book/171.html" class="sidebar-link"> 多个promise实现</a></li><li><a href="/book/131.html" class="sidebar-link"> Object.defineProperty和Object.defineProperties()</a></li><li><a href="/book/126.html" class="sidebar-link"> scrollHeight,scrollLeft,offsetHeight,offsetLeft</a></li><li><a href="/book/118.html" class="sidebar-link"> 怎样让 forEach 停下来呢；**try catch**</a></li><li><a href="/book/105.html" class="sidebar-link">div拖动的实现</a></li><li><a href="/book/93.html" class="sidebar-link">JavaScript对象之深拷贝和浅拷贝</a></li><li><a href="/book/92.html" class="sidebar-link">base64。js</a></li><li><a href="/book/85.html" class="sidebar-link">你也许不知道的JavaScript高级函数</a></li><li><a href="/book/78.html" class="sidebar-link">ESmodules:Acartoondeep-dive</a></li><li><a href="/book/73.html" class="sidebar-link">setTimeout和setImmediate到底谁先执行，本文让你彻底理解EventLoop</a></li><li><a href="/book/71.html" class="sidebar-link">一种对开发更友好的前端骨架屏自动生成方案</a></li><li><a href="/book/68.html" class="sidebar-link">深入理解ESModules(手绘示例)</a></li><li><a href="/book/48.html" class="sidebar-link">系统学习前端之FormData详解</a></li><li><a href="/book/47.html" class="sidebar-link">使用FormData上传文件</a></li><li><a href="/book/46.html" class="sidebar-link">数组排序方法</a></li><li><a href="/book/43.html" class="sidebar-link">利于FileReader实现二进制数据流转JSON</a></li><li><a href="/book/28.html" class="sidebar-link">reduce过滤数组中重复对象</a></li><li><a href="/book/27.html" class="sidebar-link">常用文件类型对应</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>element-ui</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Qcanvas</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>linux</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/365.html" class="sidebar-link"> WASM 在动画引擎中的设计优化</a></li><li><a href="/book/364.html" class="sidebar-link"> 你管这破玩意叫指针？</a></li><li><a href="/book/362.html" class="sidebar-link"> 图说 WebAssembly</a></li><li><a href="/book/328.html" class="sidebar-link"> 从哲学层面浅谈计算机学习方法论</a></li><li><a href="/book/324.html" class="sidebar-link"> 微信游览器，解决安卓和ios自动播放音乐</a></li><li><a href="/book/323.html" class="sidebar-link"> CSS3 animation属性中的steps功能符深入介绍</a></li><li><a href="/book/322.html" class="sidebar-link"> 前端搞工程化：从零打造性能检测库「源码 + 视频」</a></li><li><a href="/book/321.html" class="sidebar-link"> 还在看那些老掉牙的性能优化文章么？这些最新性能指标了解下</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/301.html" class="sidebar-link">从App store下载App的不同版本ipa文件----很多东西也不是越新越好，比如APP——在 iPhone 上尤其如此</a></li><li><a href="/book/294.html" class="sidebar-link">迟子建老师的《一坛猪油》</a></li><li><a href="/book/288.html" class="sidebar-link">文本文档的协同编辑实现</a></li><li><a href="/book/287.html" class="sidebar-link">再见，整洁代码</a></li><li><a href="/book/286.html" class="sidebar-link"> 可以在 Nginx 中运行 JavaScript，厉害了！</a></li><li><a href="/book/284.html" class="sidebar-link"> word中批量调整图片大小</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>electron打包的一些问题</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/274.html" class="sidebar-link"> 文件分片代码</a></li><li><a href="/book/273.html" class="sidebar-link"> 重学 JS：为啥 await 不能用在 forEach 中详解</a></li><li><a href="/book/269.html" class="sidebar-link"> Excel函数之王，Vlookup到底怎么用？</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mysql</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/248.html" class="sidebar-link"> 《提问的智慧》精读注解版</a></li><li><a href="/book/199.html" class="sidebar-link"> js监听div的resize事件</a></li><li><a href="/book/198.html" class="sidebar-link"> 引入第三方字体体积太大的问题</a></li><li><a href="/book/195.html" class="sidebar-link"> 多行溢出省略号显示（css/js）实现！</a></li><li><a href="/book/190.html" class="sidebar-link">今天带大家一起来看看下，如何实现“划词高亮”功能。</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Canvas</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工作中解决的疑难问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>nginx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/book/135.html" class="sidebar-link"> 深夜，我偷听到程序员要对session下手</a></li><li><a href="/book/132.html" class="sidebar-link"> 读 《深入浅出webpack》</a></li><li><a href="/book/103.html" class="sidebar-link"> 一道被人轻视的前端面试题</a></li><li><a href="/book/101.html" class="sidebar-link">部分前端面试题参考答案</a></li><li><a href="/book/80.html" class="sidebar-link">SVGDeveloper制作矢量地图教程详解</a></li><li><a href="/book/76.html" class="sidebar-link">VisualStudio2010创建的WCF（.dll）服务第一个应用</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript操作dom常用的api"><a href="#javascript操作dom常用的api" class="header-anchor">#</a> JavaScript操作DOM常用的API</h1> <h1 id="_1-什么是dom"><a href="#_1-什么是dom" class="header-anchor">#</a> 1 什么是DOM</h1> <p>文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。文档对象模型 (DOM) 是对HTML文件的另一种展示，通俗地说，一个HTML 文件，我们可以用编辑器以代码的形式展示它，也可以用浏览器以页面的形式展示它，同一份文件通过不同的展示方式，就有了不一样的表现形式。而DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来，我们可以使用脚本或者程序语言通过DOM 来改变或者控制web页面。</p> <h1 id="_2-如何访问dom"><a href="#_2-如何访问dom" class="header-anchor">#</a> 2 如何访问DOM</h1> <p>我们可以通过JavaScript 来调用document和window元素的API来操作文档或者获取文档的信息。</p> <h1 id="_3-node"><a href="#_3-node" class="header-anchor">#</a> 3 Node</h1> <p>Node 是一个接口，有许多接口都从Node 继承方法和属性：Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference。Node 有一个nodeType的属性表示Node 的类型，是一个整数，不同的值代表不同的节点类型。具体如下表所示：</p> <p><strong>节点类型常量</strong></p> <p><strong>已弃用的节点类型常量</strong></p> <p>假设我们要判断一个Node 是不是一个元素，通过查表可知元素的nodeType属性值为1，代码可以这么写：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码if(X.nodeType === 1){
  console.log('X 是一个元素');
}
</code></pre></div><p>在Node 类型中，比较常用的就是element，text，comment，document，document_fragment这几种类型。</p> <h1 id="_3-1-element"><a href="#_3-1-element" class="header-anchor">#</a> 3.1 Element</h1> <p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：（1）nodeType为1（2）nodeName为元素标签名，tagName也是返回标签名（3）nodeValue为null（4）parentNode可能是Document或Element（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</p> <h1 id="_3-2-text"><a href="#_3-2-text" class="header-anchor">#</a> 3.2 Text</h1> <p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：（1）nodeType为3（2）nodeName为#text（3）nodeValue为文本内容（4）parentNode是一个Element（5）没有子节点</p> <h1 id="_3-3-comment"><a href="#_3-3-comment" class="header-anchor">#</a> 3.3 Comment</h1> <p>Comment表示HTML文档中的注释，它有下面的几种特征：（1）nodeType为8（2）nodeName为#comment（3）nodeValue为注释的内容（4）parentNode可能是Document或Element（5）没有子节点</p> <h1 id="_3-4-document"><a href="#_3-4-document" class="header-anchor">#</a> 3.4 Document</h1> <p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性：（1）nodeType为9（2）nodeName为#document（3）nodeValue为null（4）parentNode为null（5）子节点可能是一个DocumentType或Element</p> <h1 id="_3-5-documentfragment"><a href="#_3-5-documentfragment" class="header-anchor">#</a> 3.5 DocumentFragment</h1> <p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：（1）nodeType为11（2）nodeName为#document-fragment（3）nodeValue为null（4）parentNode为null</p> <h1 id="_4-节点创建型api"><a href="#_4-节点创建型api" class="header-anchor">#</a> 4 节点创建型API</h1> <p>用如其名，这类API是用来创建节点的</p> <h1 id="_4-1-createelement"><a href="#_4-1-createelement" class="header-anchor">#</a> 4.1 createElement</h1> <p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  let element = document.createElement(tagName);
</code></pre></div><p>使用createElement要注意：通过createElement创建的元素并不属于HTML文档，它只是创建出来，并未添加到HTML文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  let elem = document.createElement(&quot;div&quot;);
  elem.id = 'test';
  elem.style = 'color: red';
  elem.innerHTML = '我是新创建的节点';
  document.body.appendChild(elem);
</code></pre></div><p>运行结果为：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/84eb5afee6954ab78a5acd4978fddc4a~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=T0hQLHdnUIxB7omAJz1cwaxhip0%3D" alt=""></p> <h1 id="_4-2-createtextnode"><a href="#_4-2-createtextnode" class="header-anchor">#</a> 4.2 createTextNode</h1> <p>createTextNode用来创建一个文本节点</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var text = document.createTextNode(data);
</code></pre></div><p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var node = document.createTextNode(&quot;我是文本节点&quot;);
  document.body.appendChild(node);
</code></pre></div><p>运行结果为：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/538124dc17c143a094e0d9887b4228d8~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=iFCBGoX6r5mXylCMow6Ykut2EWI%3D" alt=""></p> <h1 id="_4-3-clonenode"><a href="#_4-3-clonenode" class="header-anchor">#</a> 4.3 cloneNode</h1> <p>cloneNode返回调用该方法的节点的一个副本</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var dupNode = node.cloneNode(deep);
</code></pre></div><p>node 将要被克隆的节点dupNode 克隆生成的副本节点deep（可选）是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身.</p> <p>这里有几点要注意：（1）和createElement一样，cloneNode创建的节点只是游离有HTML文档外的节点，要调用appendChild方法才能添加到文档树中（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id（3）调用接收的deep参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p> <p><strong>注意</strong>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件（2）如果是内联方式绑定比如：</p><div onclick="showParent()"></div>，这样的话，副本节点同样会触发事件。<p></p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    我是父元素的文本
    &lt;br/&gt;
    &lt;span&gt;
        我是子元素
    &lt;/span&gt;
  &lt;/div&gt;
  &lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  var parent = document.getElementById(&quot;parent&quot;);
  document.getElementById(&quot;btnCopy&quot;).onclick = function(){
  	var parent2 = parent.cloneNode(true);
  	parent2.id = &quot;parent2&quot;;
  	document.body.appendChild(parent2);
  }
&lt;/script&gt;
</code></pre></div><p>运行结果为：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e361f5b102274831bcdb38fe6baccca1~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=%2FM8MnczirJyQVwlo2NsjGsAPpek%3D" alt=""></p> <h1 id="_4-4-createdocumentfragment"><a href="#_4-4-createdocumentfragment" class="header-anchor">#</a> 4.4 createDocumentFragment</h1> <p>DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流(reflow)(对元素位置和几何上的计算)。因此，使用文档片段document fragments 通常会起到优化性能的作用。</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  let fragment = document.createDocumentFragment();
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;
&lt;/body&gt;
&lt;script&gt;
  (function()
  {
    var start = Date.now();
    var str = '', li;
    var ul = document.getElementById('ul');
    var fragment = document.createDocumentFragment();
    for(var i=0; i&lt;1000; i++)
    {
        li = document.createElement('li');
        li.textContent = '第'+(i+1)+'个子节点';
        fragment.appendChild(li);
    }
    ul.appendChild(fragment);
  })();
&lt;/script&gt;
</code></pre></div><p>运行结果为：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3e1d2d8d209b4677a81cba1ee4bd543f~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=%2B2NkJMztat%2FGO6%2FIMHT50RYIBG0%3D" alt=""></p> <h1 id="_4-5-节点创建型api总结"><a href="#_4-5-节点创建型api总结" class="header-anchor">#</a> 4.5 节点创建型API总结</h1> <p>节点创建型API主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题（3）使用createDocumentFragment来解决添加大量节点时的性能问题</p> <h1 id="_5-页面修改型api"><a href="#_5-页面修改型api" class="header-anchor">#</a> 5 页面修改型API</h1> <p>前面我们提到节点创建型API，它们只是创建节点，并没有真正修改到页面内容，而是要调用·appendChild·来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p> <h1 id="_5-1-appendchild"><a href="#_5-1-appendchild" class="header-anchor">#</a> 5.1 appendChild</h1> <p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  parent.appendChild(child);
</code></pre></div><p>child节点将会作为parent节点的最后一个子节点。appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。如果child绑定了事件，被移动时，它依然绑定着该事件。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;child&quot;&gt;
    要被添加的节点
  &lt;/div&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;div id=&quot;parent&quot;&gt;
    要移动的位置
  &lt;/div&gt;
  &lt;input id=&quot;btnMove&quot; type=&quot;button&quot; value=&quot;移动节点&quot; /&gt;
&lt;/body&gt;
&lt;script&gt;
  document.getElementById(&quot;btnMove&quot;).onclick = function(){
	  var child = document.getElementById(&quot;child&quot;);
 	  document.getElementById(&quot;parent&quot;).appendChild(child);
  } 
&lt;/script&gt;
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/75a0488079cd499c8d152dd7602ea791~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=kK5eANAiKPH7UTCvEWLYgCRTv90%3D" alt=""></p> <h1 id="_5-2-insertbefore"><a href="#_5-2-insertbefore" class="header-anchor">#</a> 5.2 insertBefore</h1> <p>insertBefore用来添加一个节点到一个参照节点之前</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  parentNode.insertBefore(newNode,refNode);
</code></pre></div><p>parentNode表示新节点被添加后的父节点newNode表示要添加的节点refNode表示参照节点，新节点会添加到这个节点之前</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    父节点
    &lt;div id=&quot;child&quot;&gt;		
        子元素
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;插入节点&quot; /&gt;
&lt;/body&gt;
&lt;script&gt;
  var parent = document.getElementById(&quot;parent&quot;);
  var child = document.getElementById(&quot;child&quot;);
  document.getElementById(&quot;insertNode&quot;).onclick = function(){
  	var newNode = document.createElement(&quot;div&quot;);
  	newNode.textContent = &quot;新节点&quot;
  	parent.insertBefore(newNode,child);
  }
&lt;/script&gt;
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/6298956acc1d4bd39c06f3e28885d453~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=JeX6ukfqUK%2Ftjtq8e2SF9CsZklk%3D" alt=""></p> <p>关于第二个参数参照节点还有几个注意的地方：（1）refNode是必传的，如果不传该参数会报错（2）如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</p> <h1 id="_5-3-removechild"><a href="#_5-3-removechild" class="header-anchor">#</a> 5.3 removeChild</h1> <p>删除指定的子节点并返回</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var deletedChild = parent.removeChild(node);
</code></pre></div><p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码if(node.parentNode){
    node.parentNode.removeChild(node);
}
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/eb6fa83fbfbe4bb09315de6ddf2c6671~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=PquZLHHrVRjVBNKI9MCJqJKhvsA%3D" alt=""></p> <p>通过节点自己获取节点的父节点，然后将自身删除</p> <h1 id="_5-4-replacechild"><a href="#_5-4-replacechild" class="header-anchor">#</a> 5.4 replaceChild</h1> <p>replaceChild用于使用一个节点替换另一个节点</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  parent.replaceChild(newChild,oldChild);
</code></pre></div><p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置oldChild是被替换的节点</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    父节点
    &lt;div id=&quot;child&quot;&gt;		
        子元素
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;替换节点&quot; /&gt;
&lt;/body&gt;
&lt;script&gt;
  var parent = document.getElementById(&quot;parent&quot;);
  var child = document.getElementById(&quot;child&quot;);
  document.getElementById(&quot;insertNode&quot;).onclick = function(){
  	var newNode = document.createElement(&quot;div&quot;);
  	newNode.textContent = &quot;新节点&quot;
  	parent.replaceChild(newNode,child)
  }
</code></pre></div><p>运行结果：</p> <p><img src="https://p6-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/5442258854ca4e4fb6f401d0f03d21af~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=fcoBpzYNmOlqsElKd9F9z7Il3Lo%3D" alt=""></p> <h1 id="_5-5-页面修改型api总结"><a href="#_5-5-页面修改型api总结" class="header-anchor">#</a> 5.5 页面修改型API总结</h1> <p>页面修改型API主要是这四个接口，要注意几个特点：（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置（2）节点本身绑定的事件会不会消失，会一直保留着。</p> <h1 id="_6-节点查询型api"><a href="#_6-节点查询型api" class="header-anchor">#</a> 6 节点查询型API</h1> <h1 id="_6-1-document-getelementbyid"><a href="#_6-1-document-getelementbyid" class="header-anchor">#</a> 6.1 document.getElementById</h1> <p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var element = document.getElementById(id);
</code></pre></div><p>使用这个接口有几点要注意：（1）元素的Id是大小写敏感的，一定要写对元素的id（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;p id=&quot;para1&quot;&gt;Some text here&lt;/p&gt;
  &lt;button onclick=&quot;changeColor('blue');&quot;&gt;blue&lt;/button&gt;
  &lt;button onclick=&quot;changeColor('red');&quot;&gt;red&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  function changeColor(newColor) {
    var elem = document.getElementById(&quot;para1&quot;);
    elem.style.color = newColor;
  }
&lt;/script&gt;
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3992cf7656514af4b91472308bc84ac7~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=An%2BxzjAWCuxo7qxpxZB79J3NbMw%3D" alt=""></p> <h1 id="_6-2-document-getelementsbytagname"><a href="#_6-2-document-getelementsbytagname" class="header-anchor">#</a> 6.2 document.getElementsByTagName</h1> <p>返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用
document.getElementsByTagName()</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByTagName(name);
</code></pre></div><p>（1）如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率（2）如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection（3）name是一个代表元素的名称的字符串。特殊字符 &quot;*&quot; 代表了所有元素。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div&gt;div1&lt;/div&gt;
  &lt;div&gt;div2&lt;/div&gt;
  &lt;input type=&quot;button&quot; value=&quot;显示数量&quot; id=&quot;btnShowCount&quot;/&gt;
  &lt;input type=&quot;button&quot; value=&quot;新增div&quot; id=&quot;btnAddDiv&quot;/&gt;
&lt;/body&gt;
&lt;script&gt;
  var divList = document.getElementsByTagName(&quot;div&quot;);
  document.getElementById(&quot;btnAddDiv&quot;).onclick = function(){
  	var div = document.createElement(&quot;div&quot;);
  	div.textContent =&quot;div&quot; + (divList.length+1);
  	document.body.appendChild(div);
  }
  document.getElementById(&quot;btnShowCount&quot;).onclick = function(){
    alert(divList.length);
  }
&lt;/script&gt;
</code></pre></div><p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。</p> <p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/bf79f945832345f3b1985fa287fed046~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=hj036qjGkinFcr%2FkO18sk7ZRO8E%3D" alt=""></p> <h1 id="_6-3-document-getelementsbyname"><a href="#_6-3-document-getelementsbyname" class="header-anchor">#</a> 6.3 document.getElementsByName</h1> <p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByName(name) 
</code></pre></div><p>使用这个接口主要要注意几点：（1）返回对象是一个即时的NodeList，它是随时变化的（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;script type=&quot;text/javascript&quot;&gt;
  function getElements()
   {
   var x=document.getElementsByName(&quot;myInput&quot;);
   alert(x.length);
   }
&lt;/script&gt;
&lt;body&gt;
  &lt;input name=&quot;myInput&quot; type=&quot;text&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  &lt;input name=&quot;myInput&quot; type=&quot;text&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  &lt;input name=&quot;myInput&quot; type=&quot;text&quot; size=&quot;20&quot; /&gt;&lt;br /&gt;
  &lt;br /&gt;
  &lt;input type=&quot;button&quot; onclick=&quot;getElements()&quot; value=&quot;How many elements named 'myInput'?&quot; /&gt;
&lt;/body&gt;
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/10eb60f4880e4ab6a558ccb5a3974c88~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=exPqLLpXWCCGU3A%2BniFKZXO3QRg%3D" alt=""></p> <h1 id="_6-4-document-getelementsbyclassname"><a href="#_6-4-document-getelementsbyclassname" class="header-anchor">#</a> 6.4 document.getElementsByClassName</h1> <p>这个API是根据元素的class返回一个即时的HTMLCollection</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByClassName(names); // or:
  var elements = rootElement.getElementsByClassName(names);
</code></pre></div><ul><li>elements是一个实时集合，包含了找到的所有元素</li> <li>names是一个字符串，表示要匹配的类名列表；类名通过空格分隔</li> <li>getElementsByClassName可以在任何元素上调用，不仅仅是document。调用这个方法的元素将作为本次查找的根元素</li></ul> <p>这个接口有下面几点要注意：（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化（2）IE9以下浏览器不支持（3）如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByClassName(&quot;test1 test2&quot;);
</code></pre></div><p>例子：</p> <ul><li>获取所有class为 'test' 的元素</li></ul> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByClassName('test');
</code></pre></div><ul><li>获取所有class同时包括 'red' 和 'test' 的元素</li></ul> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementsByClassName('red test');
</code></pre></div><ul><li>在id为'main'的元素的子节点中，获取所有class为'test'的元素</li></ul> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elements = document.getElementById('main').getElementsByClassName('test');
</code></pre></div><ul><li>我们还可以对任意的HTMLCollection 使用Array.prototype的方法，调用时传递HTMLCollection 作为方法的参数。这里我们将查找到所有class为'test'的div元素:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var testElements = document.getElementsByClassName('test');
  var testDivs = Array.prototype.filter.call(testElements, function(testElement){
    return testElement.nodeName === 'DIV';;
  });
</code></pre></div><h1 id="_6-5-document-queryselector和document-queryselectorall"><a href="#_6-5-document-queryselector和document-queryselectorall" class="header-anchor">#</a> 6.5 document.querySelector和document.querySelectorAll</h1> <p>这两个API很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则</p> <ul><li><strong>6.5.1 document.querySelector</strong></li></ul> <p>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var element = document.querySelector(selectors);
</code></pre></div><p>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;span class=&quot;test&quot;&gt;第三级的span&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;test&quot;&gt;	
    同级的第二个div
  &lt;/div&gt;
  &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;获取test元素&quot; /&gt;
&lt;/body&gt;
&lt;script&gt;
  document.getElementById(&quot;btnGet&quot;).addEventListener(&quot;click&quot;,function(){
    var element = document.querySelector(&quot;.test&quot;);
    alert(element.textContent);
  })
&lt;/script&gt;
</code></pre></div><p>两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/2ead12b6227c492ebd75e6f6abefb5c1~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=fZDcRhySY146nByEn9Fwgp1u76A%3D" alt=""></p> <ul><li><strong>6.5.2 document.querySelectorAll</strong>返回的是所有匹配的元素，而且可以匹配多个选择符</li></ul> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var elementList = document.querySelectorAll(selectors);
</code></pre></div><ul><li>elementList是一个静态的NodeList类型的对象</li> <li>selectors是一个由逗号连接的包含一个或多个CSS选择器的字符串</li> <li>如果selectors参数中包含CSS伪元素,则返回一个空的elementList</li></ul> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var matches = document.querySelectorAll(&quot;div.note, div.alert&quot;);
</code></pre></div><p>返回一个文档中所有的class为&quot;note&quot;或者&quot;alert&quot;的div元素</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div class=&quot;test&quot;&gt;
    class为test
  &lt;/div&gt;
  &lt;div id=&quot;test&quot;&gt;
    id为test
  &lt;/div&gt;
  &lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;显示内容&quot; /&gt;
&lt;/body&gt;
&lt;script&gt;
  document.getElementById(&quot;btnShow&quot;).addEventListener(&quot;click&quot;,function(){
	var elements = document.querySelectorAll(&quot;#test,.test&quot;);
	for(var i = 0,length = elements.length;i&lt;length;i++){
		alert(elements[i].textContent);
	}
  })
&lt;/script&gt;
</code></pre></div><p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p> <p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/b46ee8cc0881413b94e84cef592e12da~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=DPITiUejbbTqvTKxewKGGwWJMSY%3D" alt=""></p> <h1 id="_7-节点关系型api"><a href="#_7-节点关系型api" class="header-anchor">#</a> 7 节点关系型API</h1> <p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等</p> <h1 id="_7-1-父关系型api"><a href="#_7-1-父关系型api" class="header-anchor">#</a> 7.1 父关系型API</h1> <h1 id="_7-1-1-parentnode"><a href="#_7-1-1-parentnode" class="header-anchor">#</a> 7.1.1 parentNode</h1> <p>每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment</p> <h1 id="_7-1-2-parentelement"><a href="#_7-1-2-parentelement" class="header-anchor">#</a> 7.1.2 parentElement</h1> <p>返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p> <h1 id="_7-2-子关系型appi"><a href="#_7-2-子关系型appi" class="header-anchor">#</a> 7.2 子关系型APPI</h1> <h1 id="_7-2-1-childnodes"><a href="#_7-2-1-childnodes" class="header-anchor">#</a> 7.2.1 childNodes</h1> <p>返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等</p> <h1 id="_7-2-2-children"><a href="#_7-2-2-children" class="header-anchor">#</a> 7.2.2 children：</h1> <p>一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持children属性为只读属性，对象类型为HTMLCollection，你可以使用
elementNodeReference.children[1].nodeName来获取某个子元素的标签名称</p> <h1 id="_7-2-3-firstchild"><a href="#_7-2-3-firstchild" class="header-anchor">#</a> 7.2.3 firstChild</h1> <p>只读属性返回树中节点的第一个子节点，如果节点是无子节点，则返回 null</p> <h1 id="_7-2-4-lastchild"><a href="#_7-2-4-lastchild" class="header-anchor">#</a> 7.2.4 lastChild</h1> <p>返回当前节点的最后一个子节点。如果父节点为一个元素节点，则子节点通常为一个元素节点，或一个文本节点，或一个注释节点。如果没有子节点，则返回null</p> <h1 id="_7-2-5-haschildnodes"><a href="#_7-2-5-haschildnodes" class="header-anchor">#</a> 7.2.5 hasChildNodes</h1> <p>返回一个布尔值,表明当前节点是否包含有子节点.</p> <h1 id="_7-3-兄弟关系型api"><a href="#_7-3-兄弟关系型api" class="header-anchor">#</a> 7.3 兄弟关系型API</h1> <h1 id="_7-3-1-previoussibling"><a href="#_7-3-1-previoussibling" class="header-anchor">#</a> 7.3.1 previousSibling</h1> <p>返回当前节点的前一个兄弟节点,没有则返回nullGecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点</p> <h1 id="_7-3-2-previouselementsibling"><a href="#_7-3-2-previouselementsibling" class="header-anchor">#</a> 7.3.2 previousElementSibling</h1> <p>previousElementSibling返回当前元素在其父元素的子元素节点中的前一个元素节点,如果该元素已经是第一个元素节点,则返回null,该属性是只读的。注意IE9以下浏览器不支持</p> <h1 id="_7-3-3-nextsibling"><a href="#_7-3-3-nextsibling" class="header-anchor">#</a> 7.3.3 nextSibling</h1> <p>Node.nextSibling是一个只读属性，返回其父节点的childNodes列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回nullGecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点</p> <h1 id="_7-3-4-nextelementsibling"><a href="#_7-3-4-nextelementsibling" class="header-anchor">#</a> 7.3.4 nextElementSibling</h1> <p>nextElementSibling返回当前元素在其父元素的子元素节点中的后一个元素节点,如果该元素已经是最后一个元素节点,则返回null,该属性是只读的。注意IE9以下浏览器不支持</p> <h1 id="_8-元素属性型api"><a href="#_8-元素属性型api" class="header-anchor">#</a> 8 元素属性型API</h1> <h1 id="_8-1-setattribute"><a href="#_8-1-setattribute" class="header-anchor">#</a> 8.1 setAttribute</h1> <p>设置指定元素上的一个属性值。如果属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  element.setAttribute(name, value);
</code></pre></div><p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;div1&quot;&gt;ABC&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;  
  let div1 = document.getElementById(&quot;div1&quot;); 
  div1.setAttribute(&quot;align&quot;, &quot;center&quot;);
&lt;/script&gt;
</code></pre></div><p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/5ed3e4f863194bfcb457614da4c605d8~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=AvvJdHw33zkn5am9xu5HHGOf0LM%3D" alt=""></p> <p>如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  element.setAttribute(&quot;id&quot;,&quot;test&quot;);
  element.id = &quot;test&quot;;
</code></pre></div><h1 id="_8-2-getattribute"><a href="#_8-2-getattribute" class="header-anchor">#</a> 8.2 getAttribute</h1> <p>getAttribute()返回元素上一个指定的属性值。如果指定的属性不存在，则返回null或&quot;&quot;（空字符串）</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  let attribute = element.getAttribute(attributeName);  
</code></pre></div><p>attribute是一个包含attributeName属性值的字符串。attributeName是你想要获取的属性值的属性名称</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;div1&quot;&gt;ABC&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;  
  let div1 = document.getElementById(&quot;div1&quot;);
  let align = div1.getAttribute(&quot;align&quot;);
  alert(align);
&lt;/script&gt;  
</code></pre></div><p>运行结果：</p> <p><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/0e1883a8142d44c6919844ee57c40e7b~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=attFTgSHWezCcEz1wCvK4mVnev8%3D" alt=""></p> <h1 id="_8-3-removeattribute"><a href="#_8-3-removeattribute" class="header-anchor">#</a> 8.3 removeAttribute</h1> <p>removeAttribute()从指定的元素中删除一个属性</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  element.removeAttribute(attrName)
</code></pre></div><p>attrName是一个字符串，将要从元素中删除的属性名</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码&lt;body&gt;
  &lt;div id=&quot;div1&quot; style=&quot;color:red&quot; width=&quot;200px&quot;&gt;ABC
   &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;  
  let div = document.getElementById(&quot;div1&quot;)
  div.removeAttribute(&quot;style&quot;);
&lt;/script&gt;
</code></pre></div><p>在运行之前div有个style=&quot;color:red&quot;的属性，在运行之后这个属性就被删除了</p> <p>运行结果：</p> <p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/a6d3901c354b4edf82a3b13e1575ea9b~tplv-tt-origin-asy2:5aS05p2hQOeIseaRuOmxvOeahOeoi-W6j-WRmA==.image?_iz=58558&amp;from=article.pc_detail&amp;x-expires=1693577428&amp;x-signature=tcjnfssKUpUQvfgaDxf5Ylaz1S8%3D" alt=""></p> <h1 id="_9-元素样式型api"><a href="#_9-元素样式型api" class="header-anchor">#</a> 9 元素样式型API</h1> <h1 id="_9-1-window-getcomputedstyle"><a href="#_9-1-window-getcomputedstyle" class="header-anchor">#</a> 9.1 window.getComputedStyle</h1> <p>Window.getComputedStyle()方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var style = window.getComputedStyle(element[, pseudoElt]);
</code></pre></div><p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。返回的style是一个CSSStyleDeclaration对象。通过style可以访问到元素计算后的样式</p> <h1 id="_9-2-getboundingclientrect"><a href="#_9-2-getboundingclientrect" class="header-anchor">#</a> 9.2 getBoundingClientRect</h1> <p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置</p> <p><strong>语法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var clientRect = element.getBoundingClientRect();
</code></pre></div><p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据</p> <h1 id="_9-3-直接修改元素的样式"><a href="#_9-3-直接修改元素的样式" class="header-anchor">#</a> 9.3 直接修改元素的样式</h1> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  elem.style.color = 'red';
  elem.style.setProperty('font-size', '16px');
  elem.style.removeProperty('color');
</code></pre></div><h1 id="_9-4-动态添加样式规则"><a href="#_9-4-动态添加样式规则" class="header-anchor">#</a> 9.4 动态添加样式规则</h1> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>复制代码  var style = document.createElement('style');
  style.innerHTML = 'body{color:red} #top:hover{background-color: red;color: white;}';
  document.head.appendChild(style););
</code></pre></div><h1 id="_10-总结"><a href="#_10-总结" class="header-anchor">#</a> 10 总结</h1> <p>JavaScript中的API太多了，将这些API记住并熟练使用对JavaScript的学习是有很大的帮助</p> <blockquote><p>作者：yyzclyang</p> <p>链接：
https://juejin.cn/post/6844903604445249543</p></blockquote> <p>文章来源：https://www.toutiao.com/article/7270445667334767156/?app=news_article&amp;timestamp=1692972607&amp;use_new_style=1&amp;req_id=20230825221007B737D9775EA46D8DAB6C&amp;group_id=7270445667334767156&amp;wxshare_count=1&amp;tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;utm_campaign=client_share&amp;share_token=bf99c45f-7c8d-4c48-9541-239715d1b9c8&amp;source=m_redirect</p> <!----></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/194.html" class="prev">
        DOM 事件流（event flow ）存在三个阶段：**事件捕获阶段、处于目标阶段、事件冒泡阶段。**
      </a></span> <span class="next"><a href="/book/366.html">
         JavaScript 内存泄漏
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><section class="side-anchor"><ul style="display:none;"></ul></section></div></div>
    <script src="/book/assets/js/app.5040eec0.js" defer></script><script src="/book/assets/js/3.0d5fb1e8.js" defer></script><script src="/book/assets/js/150.a81273ed.js" defer></script><script src="/book/assets/js/4.4c5f7830.js" defer></script>
  </body>
</html>
